# 🔄 IEPON 상태 관리 설계

> **연결 문서**: [05_컴포넌트_설계.md](./05_컴포넌트_설계.md) | [07_API_설계.md](./07_API_설계.md) | [12_개발_가이드.md](./12_개발_가이드.md)

---

## 6.1 상태 관리 아키텍처

### 6.1.1 Alpine.js 기반 상태 관리
```javascript
// 전역 상태 구조 (Alpine.js 스토어)
Alpine.store('appState', {
  // 인증 상태
  auth: {
    user: null,
    isAuthenticated: false,
    isLoading: false,
    license: null
  },
  // 학생 데이터
  students: {
    list: [],
    selected: null,
    isLoading: false,
    error: null
  },
  // 교육 계획/평가
  education: {
    currentLevels: [],
    monthlyPlans: [],
    evaluations: [],
    isLoading: false,
    error: null
  },
  // UI 상태
  ui: {
    sidebarOpen: false,
    currentPage: 'dashboard',
    notifications: [],
    theme: 'light'
  },
  // 설정
  settings: {
    language: 'ko',
    accessibilityMode: false,
    autoSave: true
  }
});
```

### 6.1.2 상태 관리 전략
- **Alpine.js 스토어**: 전역 상태 관리 (인증, 학생 데이터 등)
- **x-data 지역 상태**: 컴포넌트별 독립 상태
- **HTMX 서버 상태**: 실시간 데이터 동기화
- **localStorage 지속성**: 설정 및 캐시 데이터 보관

---

## 6.2 인증 상태 관리

### 6.2.1 Alpine.js 인증 스토어 구현
```javascript
// 전역 인증 스토어
Alpine.store('auth', {
  // 상태 데이터
  user: null,
  isAuthenticated: false,
  isLoading: false,
  license: null,
  error: null,

  // 로그인 액션
  async login(email, password) {
    this.isLoading = true;
    this.error = null;
    
    try {
      const { data: { user, session }, error } = await supabase.auth.signInWithPassword({
        email: email,
        password: password
      });
      
      if (error) throw error;
      
      if (user && session) {
        this.user = user;
        this.isAuthenticated = true;
        this.isLoading = false;
        
        // 라이선스 확인
        await this.checkLicense();
        
        // 세션 정보를 localStorage에 저장
        localStorage.setItem('iepon_session', JSON.stringify({
          user: user,
          sessionTime: new Date().toISOString()
        }));
        
        return { success: true, user };
      }
    } catch (error) {
      this.isLoading = false;
      this.error = error.message || '로그인에 실패했습니다.';
      console.error('로그인 오류:', error);
      return { success: false, error: this.error };
    }
  },

  // 로그아웃 액션
  async logout() {
    try {
      await supabase.auth.signOut();
      
      // 상태 초기화
      this.user = null;
      this.isAuthenticated = false;
      this.license = null;
      this.error = null;
      
      // localStorage 정리
      localStorage.removeItem('iepon_session');
      localStorage.removeItem('iepon_cache');
      
      // 홈페이지로 리다이렉트
      window.location.href = '/login.html';
      
    } catch (error) {
      console.error('로그아웃 오류:', error);
    }
  },

  // 라이선스 확인
  async checkLicense() {
    if (!this.user) return;
    
    try {
      const { data: license, error } = await supabase
        .from('licenses')
        .select('*')
        .eq('user_id', this.user.id)
        .eq('status', 'active')
        .single();
        
      if (!error && license) {
        this.license = license;
      }
    } catch (error) {
      console.error('라이선스 확인 오류:', error);
    }
  },

  // 프로필 업데이트
  async updateProfile(profileData) {
    this.isLoading = true;
    
    try {
      const { data: { user }, error } = await supabase.auth.updateUser(profileData);
      
      if (error) throw error;
      
      this.user = user;
      this.isLoading = false;
      
      return { success: true, user };
    } catch (error) {
      this.isLoading = false;
      this.error = error.message || '프로필 업데이트에 실패했습니다.';
      return { success: false, error: this.error };
    }
  },

  // 세션 복원
  async restoreSession() {
    this.isLoading = true;
    
    try {
      const { data: { session } } = await supabase.auth.getSession();
      
      if (session?.user) {
        this.user = session.user;
        this.isAuthenticated = true;
        await this.checkLicense();
      }
    } catch (error) {
      console.error('세션 복원 오류:', error);
    } finally {
      this.isLoading = false;
    }
  },

  // 헬퍼 메서드들
  get hasValidLicense() {
    return this.license && this.license.status === 'active';
  },
  
  get isAdmin() {
    return this.user?.user_metadata?.role === 'super_admin';
  },
  
  get displayName() {
    return this.user?.user_metadata?.full_name || this.user?.email || '사용자';
  }
});
```

### 6.2.2 Alpine.js 인증 컴포넌트 패턴
```html
<!-- 인증 상태를 활용하는 컴포넌트 예시 -->
<div x-data="{
  get authState() { return $store.auth; },
  get isLoggedIn() { return this.authState.isAuthenticated; },
  get userName() { return this.authState.displayName; },
  get hasLicense() { return this.authState.hasValidLicense; },
  get isAdminUser() { return this.authState.isAdmin; }
}">
  <!-- 로그인 상태에 따른 UI 표시 -->
  <template x-if="isLoggedIn">
    <div class="user-info">
      <span x-text="userName"></span>
      <span x-show="hasLicense" class="license-badge">✅ 정품 인증</span>
      <span x-show="isAdminUser" class="admin-badge">🔧 관리자</span>
      <button @click="$store.auth.logout()" class="logout-btn">
        로그아웃
      </button>
    </div>
  </template>
  
  <!-- 로그아웃 상태 UI -->
  <template x-if="!isLoggedIn">
    <a href="/login.html" class="login-link">로그인</a>
  </template>
</div>
```

```javascript
// 인증 관련 Alpine.js 헬퍼 함수들
Alpine.data('loginForm', () => ({
  email: '',
  password: '',
  isSubmitting: false,
  
  async submitLogin() {
    if (!this.email || !this.password) {
      alert('이메일과 비밀번호를 입력해주세요.');
      return;
    }
    
    this.isSubmitting = true;
    const result = await this.$store.auth.login(this.email, this.password);
    
    if (result.success) {
      // HTMX로 대시보드 페이지 로드
      htmx.ajax('GET', '/dashboard.html', { target: 'body', swap: 'outerHTML' });
    } else {
      alert(result.error);
    }
    
    this.isSubmitting = false;
  }
}));
```

---

## 6.3 학생 데이터 상태 관리

### 6.3.1 Alpine.js 학생 스토어 구현
```javascript
// 전역 학생 데이터 스토어
Alpine.store('students', {
  // 상태 데이터
  list: [],
  selected: null,
  isLoading: false,
  error: null,
  totalCount: 0,
  
  // 필터 및 검색
  filters: {
    grade: '',
    disability: '',
    status: 'active',
    searchKeyword: ''
  },
  
  // 학생 목록 조회
  async fetchStudents(options = {}) {
    this.isLoading = true;
    this.error = null;
    
    try {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) throw new Error('인증되지 않은 사용자입니다.');
      
      let query = supabase
        .from('students')
        .select('*, student_attachments(count)', { count: 'exact' })
        .eq('user_id', user.id)
        .eq('status', this.filters.status || 'active')
        .order('name');
      
      // 필터 적용
      if (this.filters.grade) {
        query = query.eq('grade', this.filters.grade);
      }
      if (this.filters.disability) {
        query = query.eq('disability_type', this.filters.disability);
      }
      if (this.filters.searchKeyword) {
        query = query.ilike('name', `%${this.filters.searchKeyword}%`);
      }
      
      const { data, error, count } = await query;
      
      if (error) throw error;
      
      this.list = data || [];
      this.totalCount = count || 0;
      this.isLoading = false;
      
      return { success: true, data: this.list };
    } catch (error) {
      this.isLoading = false;
      this.error = error.message || '학생 목록 조회에 실패했습니다.';
      console.error('학생 조회 오류:', error);
      return { success: false, error: this.error };
    }
  },
  
  // 새 학생 추가
  async addStudent(studentData) {
    this.isLoading = true;
    this.error = null;
    
    try {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) throw new Error('인증되지 않은 사용자입니다.');
      
      // UTF-8 인코딩 검증
      if (!this.validateUTF8(studentData.name)) {
        throw new Error('학생 이름에 인코딩 오류가 있습니다.');
      }
      
      const { data, error } = await supabase
        .from('students')
        .insert([{
          ...studentData,
          user_id: user.id,
          status: 'active',
          created_at: new Date().toISOString()
        }])
        .select()
        .single();
        
      if (error) throw error;
      
      // 목록에 추가
      this.list.unshift(data);
      this.totalCount += 1;
      this.isLoading = false;
      
      return { success: true, data };
    } catch (error) {
      this.isLoading = false;
      this.error = error.message || '학생 추가에 실패했습니다.';
      console.error('학생 추가 오류:', error);
      return { success: false, error: this.error };
    }
  },

  // 학생 정보 수정
  async updateStudent(id, updates) {
    this.isLoading = true;
    this.error = null;
    
    try {
      // UTF-8 인코딩 검증 (이름 필드가 있는 경우)
      if (updates.name && !this.validateUTF8(updates.name)) {
        throw new Error('학생 이름에 인코딩 오류가 있습니다.');
      }
      
      const { data, error } = await supabase
        .from('students')
        .update({ 
          ...updates, 
          updated_at: new Date().toISOString() 
        })
        .eq('id', id)
        .select()
        .single();
        
      if (error) throw error;
      
      // 목록에서 해당 학생 정보 업데이트
      const index = this.list.findIndex(s => s.id === id);
      if (index !== -1) {
        this.list[index] = data;
      }
      
      // 선택된 학생이 수정된 학생인 경우 업데이트
      if (this.selected?.id === id) {
        this.selected = data;
      }
      
      this.isLoading = false;
      return { success: true, data };
    } catch (error) {
      this.isLoading = false;
      this.error = error.message || '학생 정보 수정에 실패했습니다.';
      console.error('학생 수정 오류:', error);
      return { success: false, error: this.error };
    }
  },
  
  // 학생 삭제 (실제로는 비활성화)
  async deleteStudent(id) {
    this.isLoading = true;
    this.error = null;
    
    try {
      const { data, error } = await supabase
        .from('students')
        .update({ 
          status: 'inactive',
          deleted_at: new Date().toISOString()
        })
        .eq('id', id)
        .select()
        .single();
        
      if (error) throw error;
      
      // 목록에서 제거
      this.list = this.list.filter(s => s.id !== id);
      this.totalCount -= 1;
      
      // 선택된 학생이 삭제된 학생인 경우 선택 해제
      if (this.selected?.id === id) {
        this.selected = null;
      }
      
      this.isLoading = false;
      return { success: true };
    } catch (error) {
      this.isLoading = false;
      this.error = error.message || '학생 삭제에 실패했습니다.';
      console.error('학생 삭제 오류:', error);
      return { success: false, error: this.error };
    }
  },
  
  // 학생 선택
  selectStudent(student) {
    this.selected = student;
    // 선택된 학생 정보를 localStorage에 저장 (세션 유지용)
    if (student) {
      localStorage.setItem('iepon_selected_student', JSON.stringify(student));
    } else {
      localStorage.removeItem('iepon_selected_student');
    }
  },
  
  // 필터 설정
  setFilters(newFilters) {
    this.filters = { ...this.filters, ...newFilters };
  },
  
  // 에러 초기화
  clearError() {
    this.error = null;
  },
  
  // UTF-8 검증 유틸리티 함수
  validateUTF8(text) {
    try {
      const encoder = new TextEncoder();
      const decoder = new TextDecoder('utf-8', { fatal: true });
      const encoded = encoder.encode(text);
      const decoded = decoder.decode(encoded);
      return decoded === text;
    } catch {
      return false;
    }
  },
  
  // 헬퍼 메서드들
  get activeStudents() {
    return this.list.filter(s => s.status === 'active');
  },
  
  get studentsByGrade() {
    const grouped = {};
    this.list.forEach(student => {
      const grade = student.grade || '미설정';
      if (!grouped[grade]) grouped[grade] = [];
      grouped[grade].push(student);
    });
    return grouped;
  }
});
```

---

## 6.4 교육 관련 상태 관리

### 6.4.1 Alpine.js 교육 스토어 구현
```javascript
// 전역 교육 데이터 스토어
Alpine.store('education', {
  // 상태 데이터
  currentLevels: [],
  monthlyPlans: [],
  monthlyEvaluations: [],
  isLoading: false,
  error: null,
  
  // 현재 선택된 데이터
  selectedLevel: null,
  selectedPlan: null,
  selectedEvaluation: null,
  
  // 현행수준 조회
  async fetchCurrentLevels(studentId) {
    this.isLoading = true;
    this.error = null;
    
    try {
      const { data, error } = await supabase
        .from('current_levels')
        .select(`
          *,
          students(name),
          curriculum_units(subject, unit_name)
        `)
        .eq('student_id', studentId)
        .order('semester', { ascending: false });
        
      if (error) throw error;
      
      this.currentLevels = data || [];
      this.isLoading = false;
      
      return { success: true, data: this.currentLevels };
    } catch (error) {
      this.isLoading = false;
      this.error = error.message || '현행수준 조회에 실패했습니다.';
      console.error('현행수준 조회 오류:', error);
      return { success: false, error: this.error };
    }
  },
  
  // 월별 교육계획 조회
  async fetchMonthlyPlans(studentId, semester) {
    this.isLoading = true;
    this.error = null;
    
    try {
      const { data, error } = await supabase
        .from('monthly_plans')
        .select(`
          *,
          students(name),
          curriculum_units(subject, unit_name, grade)
        `)
        .eq('student_id', studentId)
        .eq('semester', semester)
        .order('month');
        
      if (error) throw error;
      
      this.monthlyPlans = data || [];
      this.isLoading = false;
      
      return { success: true, data: this.monthlyPlans };
    } catch (error) {
      this.isLoading = false;
      this.error = error.message || '월별 교육계획 조회에 실패했습니다.';
      console.error('월별 계획 조회 오류:', error);
      return { success: false, error: this.error };
    }
  },
  
  // 월별 평가 조회
  async fetchMonthlyEvaluations(studentId, semester) {
    this.isLoading = true;
    this.error = null;
    
    try {
      const { data, error } = await supabase
        .from('monthly_evaluations')
        .select(`
          *,
          students(name),
          monthly_plans(unit_id, goals)
        `)
        .eq('student_id', studentId)
        .eq('semester', semester)
        .order('evaluation_date', { ascending: false });
        
      if (error) throw error;
      
      this.monthlyEvaluations = data || [];
      this.isLoading = false;
      
      return { success: true, data: this.monthlyEvaluations };
    } catch (error) {
      this.isLoading = false;
      this.error = error.message || '월별 평가 조회에 실패했습니다.';
      console.error('월별 평가 조회 오류:', error);
      return { success: false, error: this.error };
    }
  },
  
  // 현행수준 저장
  async saveCurrentLevel(levelData) {
    this.isLoading = true;
    this.error = null;
    
    try {
      // UTF-8 인코딩 검증
      if (levelData.detailed_content && !this.validateUTF8(levelData.detailed_content)) {
        throw new Error('상세내용에 인코딩 오류가 있습니다.');
      }
      
      const { data, error } = await supabase
        .from('current_levels')
        .upsert([
          {
            ...levelData,
            updated_at: new Date().toISOString()
          }
        ])
        .select()
        .single();
        
      if (error) throw error;
      
      // 기존 데이터 업데이트 또는 새 데이터 추가
      const existingIndex = this.currentLevels.findIndex(
        level => level.student_id === data.student_id && level.unit_id === data.unit_id
      );
      
      if (existingIndex !== -1) {
        this.currentLevels[existingIndex] = data;
      } else {
        this.currentLevels.unshift(data);
      }
      
      this.isLoading = false;
      return { success: true, data };
    } catch (error) {
      this.isLoading = false;
      this.error = error.message || '현행수준 저장에 실패했습니다.';
      console.error('현행수준 저장 오류:', error);
      return { success: false, error: this.error };
    }
  },
  
  // 월별 계획 저장
  async saveMonthlyPlan(planData) {
    this.isLoading = true;
    this.error = null;
    
    try {
      // UTF-8 인코딩 검증
      if (planData.goals && !this.validateUTF8(JSON.stringify(planData.goals))) {
        throw new Error('계획 목표에 인코딩 오류가 있습니다.');
      }
      
      const { data, error } = await supabase
        .from('monthly_plans')
        .upsert([
          {
            ...planData,
            updated_at: new Date().toISOString()
          }
        ])
        .select()
        .single();
        
      if (error) throw error;
      
      // 기존 데이터 업데이트 또는 새 데이터 추가
      const existingIndex = this.monthlyPlans.findIndex(
        plan => plan.student_id === data.student_id && 
               plan.unit_id === data.unit_id && 
               plan.month === data.month
      );
      
      if (existingIndex !== -1) {
        this.monthlyPlans[existingIndex] = data;
      } else {
        this.monthlyPlans.push(data);
        this.monthlyPlans.sort((a, b) => a.month - b.month);
      }
      
      this.isLoading = false;
      return { success: true, data };
    } catch (error) {
      this.isLoading = false;
      this.error = error.message || '월별 계획 저장에 실패했습니다.';
      console.error('월별 계획 저장 오류:', error);
      return { success: false, error: this.error };
    }
  },
  
  // 월별 평가 저장
  async saveMonthlyEvaluation(evaluationData) {
    this.isLoading = true;
    this.error = null;
    
    try {
      // UTF-8 인코딩 검증
      if (evaluationData.evaluation_content && !this.validateUTF8(JSON.stringify(evaluationData.evaluation_content))) {
        throw new Error('평가 내용에 인코딩 오류가 있습니다.');
      }
      
      const { data, error } = await supabase
        .from('monthly_evaluations')
        .upsert([
          {
            ...evaluationData,
            evaluation_date: evaluationData.evaluation_date || new Date().toISOString().split('T')[0],
            updated_at: new Date().toISOString()
          }
        ])
        .select()
        .single();
        
      if (error) throw error;
      
      // 기존 데이터 업데이트 또는 새 데이터 추가
      const existingIndex = this.monthlyEvaluations.findIndex(
        eval => eval.student_id === data.student_id && 
               eval.plan_id === data.plan_id && 
               eval.evaluation_date === data.evaluation_date
      );
      
      if (existingIndex !== -1) {
        this.monthlyEvaluations[existingIndex] = data;
      } else {
        this.monthlyEvaluations.unshift(data);
      }
      
      this.isLoading = false;
      return { success: true, data };
    } catch (error) {
      this.isLoading = false;
      this.error = error.message || '월별 평가 저장에 실패했습니다.';
      console.error('월별 평가 저장 오류:', error);
      return { success: false, error: this.error };
    }
  },
  
  // 선택 액션들
  selectLevel(level) {
    this.selectedLevel = level;
  },
  
  selectPlan(plan) {
    this.selectedPlan = plan;
  },
  
  selectEvaluation(evaluation) {
    this.selectedEvaluation = evaluation;
  },
  
  // 에러 초기화
  clearError() {
    this.error = null;
  },
  
  // UTF-8 검증 유틸리티 함수
  validateUTF8(text) {
    try {
      const encoder = new TextEncoder();
      const decoder = new TextDecoder('utf-8', { fatal: true });
      const encoded = encoder.encode(text);
      const decoded = decoder.decode(encoded);
      return decoded === text;
    } catch {
      return false;
    }
  },
  
  // 헬퍼 메서드들
  get currentSemesterPlans() {
    const currentSemester = new Date().getMonth() < 6 ? '1' : '2';
    return this.monthlyPlans.filter(plan => plan.semester === currentSemester);
  },
  
  get completedEvaluations() {
    return this.monthlyEvaluations.filter(eval => eval.completion_status === 'completed');
  },
  
  get pendingEvaluations() {
    return this.monthlyEvaluations.filter(eval => eval.completion_status === 'pending');
  }
});

  saveCurrentLevel: async (data) => {
    set({ isLoading: true, error: null });
    try {
      const { data: result, error } = await supabase
        .from('current_levels')
        .upsert([data])
        .select()
        .single();

      if (error) throw error;

      set(state => ({
        currentLevels: [
          ...state.currentLevels.filter(cl => 
            !(cl.student_id === data.student_id && cl.semester === data.semester)
          ),
          result
        ],
        isLoading: false
      }));
    } catch (error) {
      set({ 
        error: error instanceof Error ? error.message : '현행수준 저장 실패',
        isLoading: false 
      });
    }
  }
}));
```

---

## 6.5 교육과정 상태 관리

### 6.5.1 Alpine.js 교육과정 스토어 구현
```javascript
// 전역 교육과정 스토어
Alpine.store('curriculum', {
  // 상태 데이터
  units: [],
  selectedUnit: null,
  isLoading: false,
  error: null,
  totalCount: 0,
  
  // 필터 및 검색
  filters: {
    subject: '', // '국어', '수학', '사회', '과학', '예체'
    grade: null, // 1-6
    semester: null, // 1, 2
    searchKeyword: ''
  },
  
  // 업로드 진행상태
  uploadProgress: {
    isUploading: false,
    progress: 0,
    message: '',
    currentFile: null
  },
  
  // 교육과정 목록 조회
  async fetchUnits(customFilters = {}) {
    this.isLoading = true;
    this.error = null;
    
    try {
      // 현재 필터와 커스텀 필터 병합
      const activeFilters = { ...this.filters, ...customFilters };
      
      let query = supabase
        .from('curriculum_units')
        .select('*', { count: 'exact' })
        .eq('status', 'active')
        .order('grade', { ascending: true })
        .order('semester', { ascending: true })
        .order('unit_order', { ascending: true });
      
      // 필터 적용
      if (activeFilters.subject) {
        query = query.eq('subject', activeFilters.subject);
      }
      if (activeFilters.grade) {
        query = query.eq('grade', activeFilters.grade);
      }
      if (activeFilters.semester) {
        query = query.eq('semester', activeFilters.semester);
      }
      if (activeFilters.searchKeyword) {
        query = query.or(
          `unit_name.ilike.%${activeFilters.searchKeyword}%,` +
          `objectives.ilike.%${activeFilters.searchKeyword}%,` +
          `content_elements.ilike.%${activeFilters.searchKeyword}%`
        );
      }
      
      const { data, error, count } = await query;
      
      if (error) throw error;
      
      this.units = data || [];
      this.totalCount = count || 0;
      this.isLoading = false;
      
      return { success: true, data: this.units, count: this.totalCount };
    } catch (error) {
      this.isLoading = false;
      this.error = error.message || '교육과정 조회에 실패했습니다.';
      console.error('교육과정 조회 오류:', error);
      return { success: false, error: this.error };
    }
  },
  
  // 교육과정 검색
  async searchUnits(keyword) {
    return await this.fetchUnits({ searchKeyword: keyword });
  },
  
  // 새 교육과정 단위 생성
  async createUnit(unitData) {
    this.isLoading = true;
    this.error = null;
    
    try {
      // UTF-8 인코딩 검증
      if (unitData.unit_name && !this.validateUTF8(unitData.unit_name)) {
        throw new Error('단원명에 인코딩 오류가 있습니다.');
      }
      if (unitData.objectives && !this.validateUTF8(JSON.stringify(unitData.objectives))) {
        throw new Error('학습목표에 인코딩 오류가 있습니다.');
      }
      
      const { data, error } = await supabase
        .from('curriculum_units')
        .insert([{
          ...unitData,
          status: 'active',
          created_at: new Date().toISOString()
        }])
        .select()
        .single();
        
      if (error) throw error;
      
      // 목록에 추가
      this.units.unshift(data);
      this.totalCount += 1;
      this.isLoading = false;
      
      return { success: true, data };
    } catch (error) {
      this.isLoading = false;
      this.error = error.message || '교육과정 생성에 실패했습니다.';
      console.error('교육과정 생성 오류:', error);
      return { success: false, error: this.error };
    }
  },
  
  // 교육과정 단위 수정
  async updateUnit(id, updates) {
    this.isLoading = true;
    this.error = null;
    
    try {
      // UTF-8 인코딩 검증
      if (updates.unit_name && !this.validateUTF8(updates.unit_name)) {
        throw new Error('단원명에 인코딩 오류가 있습니다.');
      }
      if (updates.objectives && !this.validateUTF8(JSON.stringify(updates.objectives))) {
        throw new Error('학습목표에 인코딩 오류가 있습니다.');
      }
      
      const { data, error } = await supabase
        .from('curriculum_units')
        .update({ 
          ...updates, 
          updated_at: new Date().toISOString() 
        })
        .eq('id', id)
        .select()
        .single();
        
      if (error) throw error;
      
      // 목록에서 해당 항목 업데이트
      const index = this.units.findIndex(u => u.id === id);
      if (index !== -1) {
        this.units[index] = data;
      }
      
      // 선택된 단위가 수정된 단위인 경우 업데이트
      if (this.selectedUnit?.id === id) {
        this.selectedUnit = data;
      }
      
      this.isLoading = false;
      return { success: true, data };
    } catch (error) {
      this.isLoading = false;
      this.error = error.message || '교육과정 수정에 실패했습니다.';
      console.error('교육과정 수정 오류:', error);
      return { success: false, error: this.error };
    }
  },
  
  // 교육과정 단위 삭제 (실제로는 비활성화)
  async deleteUnit(id) {
    this.isLoading = true;
    this.error = null;
    
    try {
      const { data, error } = await supabase
        .from('curriculum_units')
        .update({ 
          status: 'inactive',
          deleted_at: new Date().toISOString()
        })
        .eq('id', id)
        .select()
        .single();
        
      if (error) throw error;
      
      // 목록에서 제거
      this.units = this.units.filter(u => u.id !== id);
      this.totalCount -= 1;
      
      // 선택된 단위가 삭제된 단위인 경우 선택 해제
      if (this.selectedUnit?.id === id) {
        this.selectedUnit = null;
      }
      
      this.isLoading = false;
      return { success: true };
    } catch (error) {
      this.isLoading = false;
      this.error = error.message || '교육과정 삭제에 실패했습니다.';
      console.error('교육과정 삭제 오류:', error);
      return { success: false, error: this.error };
    }
  },
  
  // 대량 교육과정 데이터 업로드
  async uploadUnits(unitsData) {
    this.uploadProgress.isUploading = true;
    this.uploadProgress.progress = 0;
    this.uploadProgress.message = '업로드 준비 중...';
    this.error = null;
    
    try {
      this.uploadProgress.progress = 20;
      this.uploadProgress.message = '데이터 검증 중...';
      
      // UTF-8 인코딩 검증
      for (const unit of unitsData) {
        if (unit.unit_name && !this.validateUTF8(unit.unit_name)) {
          throw new Error(`단원명 "${unit.unit_name}"에 인코딩 오류가 있습니다.`);
        }
      }
      
      this.uploadProgress.progress = 50;
      this.uploadProgress.message = '데이터 전송 중...';
      
      const { data, error } = await supabase
        .from('curriculum_units')
        .insert(unitsData.map(unit => ({
          ...unit,
          status: 'active',
          created_at: new Date().toISOString()
        })))
        .select();
        
      if (error) throw error;
      
      this.uploadProgress.progress = 90;
      this.uploadProgress.message = '데이터 동기화 중...';
      
      // 목록에 추가
      this.units.unshift(...data);
      this.totalCount += data.length;
      
      this.uploadProgress.progress = 100;
      this.uploadProgress.message = `${data.length}개 단원 업로드 완료!`;
      
      // 3초 후 업로드 상태 초기화
      setTimeout(() => {
        this.uploadProgress.isUploading = false;
        this.uploadProgress.progress = 0;
        this.uploadProgress.message = '';
      }, 3000);
      
      return { success: true, data, count: data.length };
    } catch (error) {
      this.uploadProgress.isUploading = false;
      this.uploadProgress.progress = 0;
      this.uploadProgress.message = '';
      this.error = error.message || '데이터 업로드에 실패했습니다.';
      console.error('대량 업로드 오류:', error);
      return { success: false, error: this.error };
    }
  },
  
  // Excel 파일 업로드
  async uploadExcel(file, subject, grade, semester) {
    this.uploadProgress.isUploading = true;
    this.uploadProgress.progress = 0;
    this.uploadProgress.message = 'Excel 파일 처리 시작...';
    this.uploadProgress.currentFile = file.name;
    this.error = null;
    
    try {
      // 파일 타입 및 크기 검증
      if (!file.name.match(/\.(xlsx|xls)$/i)) {
        throw new Error('Excel 파일만 업로드 가능합니다.');
      }
      if (file.size > 10 * 1024 * 1024) { // 10MB 제한
        throw new Error('파일 크기는 10MB를 초과할 수 없습니다.');
      }
      
      this.uploadProgress.progress = 30;
      this.uploadProgress.message = '파일 업로드 중...';
      
      const formData = new FormData();
      formData.append('file', file);
      formData.append('subject', subject);
      formData.append('grade', grade.toString());
      formData.append('semester', semester.toString());
      
      // Supabase Edge Function으로 파일 업로드
      const { data, error } = await supabase.functions.invoke('upload-curriculum-excel', {
        body: formData
      });
      
      if (error) throw error;
      
      this.uploadProgress.progress = 80;
      this.uploadProgress.message = '데이터 처리 중...';
      
      // 처리된 데이터를 DB에 저장
      if (data && data.units && data.units.length > 0) {
        const result = await this.uploadUnits(data.units);
        if (!result.success) {
          throw new Error(result.error);
        }
        
        this.uploadProgress.progress = 100;
        this.uploadProgress.message = `Excel에서 ${data.units.length}개 단원 가져오기 완료!`;
        
        return { success: true, data: data.units, count: data.units.length };
      } else {
        throw new Error('업로드된 파일에서 유효한 데이터를 찾을 수 없습니다.');
      }
    } catch (error) {
      this.uploadProgress.isUploading = false;
      this.uploadProgress.progress = 0;
      this.uploadProgress.message = '';
      this.uploadProgress.currentFile = null;
      this.error = error.message || 'Excel 파일 업로드에 실패했습니다.';
      console.error('Excel 업로드 오류:', error);
      return { success: false, error: this.error };
    }
  }, 
          error: result.error?.message || 'Excel 업로드 실패',
          uploadProgress: { isUploading: false, progress: 0, message: '' }
        });
      }
    } catch (error) {
      set({ 
        error: 'Excel 업로드 중 오류가 발생했습니다.',
        uploadProgress: { isUploading: false, progress: 0, message: '' }
      });
    }
  },

  // 선택 및 필터
  setSelectedUnit: (unit) => {
    set({ selectedUnit: unit });
  },

  setFilters: (filters) => {
    set(state => ({ filters: { ...state.filters, ...filters } }));
  },

  clearFilters: () => {
    set({ 
      filters: {
        subject: '',
        grade: null,
        semester: null,
        searchKeyword: ''
      }
    });
  },

  // 상태 관리
  setLoading: (loading) => {
    set({ isLoading: loading });
  },

  setError: (error) => {
    set({ error });
  },

  clearError: () => {
    set({ error: null });
  }
}));
```

### 6.5.2 교육과정 상태 활용 예시 (Alpine.js)
```html
<!-- 교육과정 목록 페이지 Alpine.js 컴포넌트 -->
<div 
  x-data="{
    get curriculum() { return $store.curriculum; },
    
    // 초기화 함수
    async init() {
      await this.curriculum.fetchUnits();
    },
    
    // 필터 변경 핸들러
    async handleFilterChange(newFilters) {
      this.curriculum.setFilters(newFilters);
      await this.curriculum.fetchUnits(newFilters);
    },
    
    // 삭제 핸들러 (UTF-8 안전)
    async handleDelete(id) {
      if (!id) {
        alert('삭제할 교육과정 ID가 없습니다.');
        return;
      }
      
      if (confirm('정말 삭제하시겠습니까?')) {
        const result = await this.curriculum.deleteUnit(id);
        if (result.success) {
          // UI 업데이트는 Alpine.js 반응성으로 자동 처리
          console.log('교육과정 삭제 완료:', id);
        } else {
          alert(result.error || '삭제에 실패했습니다.');
        }
      }
    }
  }"
  x-init="init()"
  class="curriculum-list-page"
>
  <!-- 교육과정 필터 섹션 -->
  <div class="curriculum-filters" 
       x-show="curriculum.units.length > 0 || curriculum.filters.searchKeyword">
    
    <!-- 검색 입력 -->
    <div class="search-section">
      <input 
        type="text" 
        x-model="curriculum.filters.searchKeyword"
        @input.debounce.500ms="handleFilterChange(curriculum.filters)"
        placeholder="교육과정 검색..."
        aria-label="교육과정 검색"
        class="search-input"
      >
    </div>
    
    <!-- 필터 옵션들 -->
    <div class="filter-options">
      <select 
        x-model="curriculum.filters.grade"
        @change="handleFilterChange(curriculum.filters)"
        aria-label="학년 필터"
        class="grade-filter"
      >
        <option value="">모든 학년</option>
        <option value="elementary">초등</option>
        <option value="middle">중등</option>
        <option value="high">고등</option>
      </select>
      
      <select 
        x-model="curriculum.filters.subject"
        @change="handleFilterChange(curriculum.filters)"
        aria-label="과목 필터"
        class="subject-filter"
      >
        <option value="">모든 과목</option>
        <option value="korean">국어</option>
        <option value="math">수학</option>
        <option value="social">사회</option>
        <option value="science">과학</option>
      </select>
    </div>
  </div>
  
  <!-- 로딩 상태 -->
  <div x-show="curriculum.isLoading" class="loading-spinner" role="status" aria-label="로딩 중">
    <div class="spinner"></div>
    <span>교육과정 목록을 불러오는 중...</span>
  </div>
  
  <!-- 에러 상태 -->
  <div x-show="curriculum.error" class="error-message" role="alert">
    <span x-text="curriculum.error"></span>
    <button @click="curriculum.clearError()" class="error-close" aria-label="에러 메시지 닫기">×</button>
  </div>
  
  <!-- 교육과정 목록 -->
  <div x-show="!curriculum.isLoading && !curriculum.error" class="curriculum-list">
    <!-- 빈 상태 -->
    <div x-show="curriculum.units.length === 0" class="empty-state">
      <p>등록된 교육과정이 없습니다.</p>
      <button @click="$dispatch('open-curriculum-form')" class="add-curriculum-btn">
        새 교육과정 추가
      </button>
    </div>
    
    <!-- 교육과정 카드들 -->
    <div x-show="curriculum.units.length > 0" class="curriculum-grid">
      <template x-for="unit in curriculum.units" :key="unit.id">
        <div class="curriculum-card">
          <div class="card-header">
            <h3 x-text="unit.title" class="unit-title"></h3>
            <span x-text="unit.grade + '학년'" class="grade-badge"></span>
          </div>
          
          <div class="card-content">
            <p x-text="unit.description || '설명이 없습니다.'" class="unit-description"></p>
            
            <div class="unit-meta">
              <span x-text="unit.subject" class="subject-tag"></span>
              <span x-text="unit.duration + '분'" class="duration-tag"></span>
            </div>
          </div>
          
          <div class="card-actions">
            <button 
              @click="$dispatch('edit-curriculum', { id: unit.id })"
              class="btn-edit"
              aria-label="교육과정 편집"
            >
              편집
            </button>
            
            <button 
              @click="handleDelete(unit.id)"
              class="btn-delete"
              aria-label="교육과정 삭제"
            >
              삭제
            </button>
          </div>
        </div>
      </template>
    </div>
  </div>
  
  <!-- 페이지네이션 -->
  <div x-show="curriculum.totalCount > curriculum.units.length" class="pagination">
    <button 
      @click="curriculum.loadMore()"
      :disabled="curriculum.isLoading"
      class="load-more-btn"
    >
      더 보기 (<span x-text="curriculum.totalCount - curriculum.units.length"></span>개 남음)
    </button>
  </div>
</div>
```

---

## 6.6 UI 상태 관리

### 6.6.1 Alpine.js UI 스토어 구현
```javascript
// 전역 UI 상태 스토어 (Alpine.js)
Alpine.store('ui', {
  // 상태 데이터
  sidebarOpen: false,
  currentPage: 'dashboard',
  modals: {}, // 모달 상태 방대 { modalId: boolean }
  notifications: [],
  theme: 'light', // 'light' | 'dark'
  
  // 사이드바 토글
  toggleSidebar() {
    this.sidebarOpen = !this.sidebarOpen;
    
    // 로컬 스토리지에 저장
    localStorage.setItem('iepon_sidebar_open', this.sidebarOpen.toString());
  },
  
  // 사이드바 닫기
  closeSidebar() {
    this.sidebarOpen = false;
    localStorage.setItem('iepon_sidebar_open', 'false');
  },
  
  // 현재 페이지 설정
  setCurrentPage(page) {
    // UTF-8 검증
    if (typeof page === 'string') {
      try {
        const encoded = new TextEncoder().encode(page);
        const decoded = new TextDecoder('utf-8', { fatal: true }).decode(encoded);
        if (decoded !== page) {
          console.error('UTF-8 인코딩 오류:', page);
          return;
        }
      } catch (error) {
        console.error('페이지 이름 UTF-8 검증 실패:', error);
        return;
      }
    }
    
    this.currentPage = page;
    
    // URL 업데이트 (브라우저 히스토리 관리)
    if (window.history && window.history.pushState) {
      const newUrl = `/${page}.html`;
      window.history.pushState({ page }, '', newUrl);
    }
  },
  
  // 모달 열기
  openModal(modalId) {
    if (!modalId) {
      console.error('모달 ID가 필요합니다.');
      return;
    }
    
    this.modals[modalId] = true;
    
    // 모달 열릴 때 body 스크롤 비활성화
    document.body.style.overflow = 'hidden';
    
    // 접근성: 포커스 관리
    this.trapFocus(modalId);
  },
  
  // 모달 닫기
  closeModal(modalId) {
    if (!modalId) {
      console.error('모달 ID가 필요합니다.');
      return;
    }
    
    this.modals[modalId] = false;
    
    // 다른 모달이 열려있는지 확인
    const hasOpenModal = Object.values(this.modals).some(isOpen => isOpen);
    if (!hasOpenModal) {
      document.body.style.overflow = '';
    }
  },
  
  // 모든 모달 닫기
  closeAllModals() {
    this.modals = {};
    document.body.style.overflow = '';
  },
  
  // 알림 추가
  addNotification(notification) {
    if (!notification || !notification.message) {
      console.error('알림 메시지가 필요합니다.');
      return;
    }
    
    // UTF-8 검증
    try {
      const encoded = new TextEncoder().encode(notification.message);
      const decoded = new TextDecoder('utf-8', { fatal: true }).decode(encoded);
      if (decoded !== notification.message) {
        console.error('알림 메시지 UTF-8 인코딩 오류');
        return;
      }
    } catch (error) {
      console.error('알림 UTF-8 검증 실패:', error);
      return;
    }
    
    const id = Date.now().toString() + Math.random().toString(36).substr(2, 9);
    const newNotification = {
      id,
      message: notification.message,
      type: notification.type || 'info', // 'success', 'error', 'warning', 'info'
      duration: notification.duration || 5000,
      createdAt: new Date().toISOString()
    };
    
    this.notifications.push(newNotification);
    
    // 자동 제거
    if (newNotification.duration > 0) {
      setTimeout(() => {
        this.removeNotification(id);
      }, newNotification.duration);
    }
    
    return id;
  },
  
  // 알림 제거
  removeNotification(id) {
    const index = this.notifications.findIndex(n => n.id === id);
    if (index > -1) {
      this.notifications.splice(index, 1);
    }
  },
  
  // 모든 알림 제거
  clearAllNotifications() {
    this.notifications = [];
  },
  
  // 테마 설정
  setTheme(theme) {
    if (!['light', 'dark'].includes(theme)) {
      console.error('지원되지 않는 테마:', theme);
      return;
    }
    
    this.theme = theme;
    
    // HTML 루트 엘리먼트에 클래스 적용
    document.documentElement.className = theme;
    
    // 로컬 스토리지에 저장
    localStorage.setItem('iepon_theme', theme);
  },
  
  // 테마 토글
  toggleTheme() {
    const newTheme = this.theme === 'light' ? 'dark' : 'light';
    this.setTheme(newTheme);
  },
  
  // 접근성: 포커스 트랩 (모달 내에서만 포커스 이동)
  trapFocus(modalId) {
    const modal = document.querySelector(`[data-modal="${modalId}"]`);
    if (!modal) return;
    
    const focusableElements = modal.querySelectorAll(
      'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
    );
    const firstElement = focusableElements[0];
    const lastElement = focusableElements[focusableElements.length - 1];
    
    // 첫 번째 요소에 포커스
    if (firstElement) {
      firstElement.focus();
    }
    
    // Tab 키 이벤트 리스너
    modal.addEventListener('keydown', (e) => {
      if (e.key === 'Tab') {
        if (e.shiftKey) {
          // Shift+Tab: 역방향
          if (document.activeElement === firstElement) {
            lastElement.focus();
            e.preventDefault();
          }
        } else {
          // Tab: 정방향
          if (document.activeElement === lastElement) {
            firstElement.focus();
            e.preventDefault();
          }
        }
      } else if (e.key === 'Escape') {
        // ESC 키로 모달 닫기
        this.closeModal(modalId);
        e.preventDefault();
      }
    });
  },
  
  // 초기화 (로캬 스토리지에서 상태 복원)
  init() {
    // 사이드바 상태 복원
    const savedSidebarState = localStorage.getItem('iepon_sidebar_open');
    if (savedSidebarState !== null) {
      this.sidebarOpen = savedSidebarState === 'true';
    }
    
    // 테마 상태 복원
    const savedTheme = localStorage.getItem('iepon_theme');
    if (savedTheme && ['light', 'dark'].includes(savedTheme)) {
      this.setTheme(savedTheme);
    }
    
    // 브라우저 히스토리 이벤트 리스너
    window.addEventListener('popstate', (event) => {
      if (event.state && event.state.page) {
        this.currentPage = event.state.page;
      }
    });
  },
  
  // Computed 속성들
  get unreadNotificationCount() {
    return this.notifications.length;
  },
  
  get isModalOpen() {
    return Object.values(this.modals).some(isOpen => isOpen);
  },
  
  get isDarkMode() {
    return this.theme === 'dark';
  }
});
```

---

## 6.7 자동저장 상태 관리

### 6.7.1 Alpine.js 자동저장 유틸리티
```javascript
// 자동저장 유틸리티 클래스 (Alpine.js 패턴)
class AutoSaveManager {
  constructor(saveFunction, delay = 3000) {
    this.saveFunction = saveFunction;
    this.delay = delay;
    this.isSaving = false;
    this.lastSaved = null;
    this.hasUnsavedChanges = false;
    this.saveTimeout = null;
    this.onStateChange = null; // 상태 변경 콜백
  }
  
  // 데이터 저장 메서드
  async save(data) {
    if (!this.saveFunction || !data) {
      console.warn('저장 함수 또는 데이터가 없습니다.');
      return false;
    }
    
    // UTF-8 안전성 검증
    if (!this.validateUTF8(data)) {
      console.error('데이터 UTF-8 인코딩 오류');
      return false;
    }
    
    this.isSaving = true;
    this.updateState();
    
    try {
      await this.saveFunction(data);
      this.lastSaved = new Date();
      this.hasUnsavedChanges = false;
      
      // 성공 알림
      if (Alpine.store('ui')) {
        Alpine.store('ui').addNotification({
          message: '자동 저장되었습니다.',
          type: 'success',
          duration: 2000
        });
      }
      
      return true;
    } catch (error) {
      console.error('자동저장 실패:', error);
      
      // 실패 알림
      if (Alpine.store('ui')) {
        Alpine.store('ui').addNotification({
          message: '자동 저장에 실패했습니다. 수동으로 저장해주세요.',
          type: 'error',
          duration: 5000
        });
      }
      
      return false;
    } finally {
      this.isSaving = false;
      this.updateState();
    }
  }
  
  // 디바운스된 저장
  scheduleSave(data) {
    if (this.saveTimeout) {
      clearTimeout(this.saveTimeout);
    }
    
    this.hasUnsavedChanges = true;
    this.updateState();
    
    this.saveTimeout = setTimeout(() => {
      this.save(data);
    }, this.delay);
  }
  
  // 즉시 저장 (디바운스 무시)
  async forceSave(data) {
    if (this.saveTimeout) {
      clearTimeout(this.saveTimeout);
      this.saveTimeout = null;
    }
    
    return await this.save(data);
  }
  
  // UTF-8 검증 메서드
  validateUTF8(data) {
    try {
      const jsonString = JSON.stringify(data);
      const encoded = new TextEncoder().encode(jsonString);
      const decoded = new TextDecoder('utf-8', { fatal: true }).decode(encoded);
      return decoded === jsonString;
    } catch (error) {
      console.error('UTF-8 검증 실패:', error);
      return false;
    }
  }
  
  // 상태 변경 알림
  updateState() {
    if (this.onStateChange) {
      this.onStateChange({
        isSaving: this.isSaving,
        lastSaved: this.lastSaved,
        hasUnsavedChanges: this.hasUnsavedChanges
      });
    }
  }
  
  // 정리 메서드
  destroy() {
    if (this.saveTimeout) {
      clearTimeout(this.saveTimeout);
      this.saveTimeout = null;
    }
  }
  
  // 상태 접근자들
  get status() {
    return {
      isSaving: this.isSaving,
      lastSaved: this.lastSaved,
      hasUnsavedChanges: this.hasUnsavedChanges,
      lastSavedText: this.lastSaved ? 
        `마지막 저장: ${this.lastSaved.toLocaleTimeString()}` : 
        '저장된 적 없음'
    };
  }
}
```

### 6.7.2 Alpine.js 폼 상태 관리 유틸리티
```javascript
// 폼 상태 관리 클래스 (Alpine.js 패턴)
class FormStateManager {
  constructor(initialData = {}, validationRules = {}) {
    this.initialData = { ...initialData };
    this.data = { ...initialData };
    this.errors = {};
    this.touched = {};
    this.isDirty = false;
    this.isSubmitting = false;
    this.validationRules = validationRules;
    this.onStateChange = null;
  }
  
  // 필드 값 업데이트
  updateField(field, value) {
    // UTF-8 검증 (string 필드의 경우)
    if (typeof value === 'string') {
      try {
        const encoded = new TextEncoder().encode(value);
        const decoded = new TextDecoder('utf-8', { fatal: true }).decode(encoded);
        if (decoded !== value) {
          console.error(`필드 ${field} UTF-8 인코딩 오류`);
          return false;
        }
      } catch (error) {
        console.error(`필드 ${field} UTF-8 검증 실패:`, error);
        return false;
      }
    }
    
    this.data[field] = value;
    this.touched[field] = true;
    this.isDirty = true;
    
    // 해당 필드 에러 제거
    if (this.errors[field]) {
      delete this.errors[field];
    }
    
    // 실시간 검증 (옵션)
    if (this.validationRules[field]) {
      this.validateField(field);
    }
    
    this.updateState();
    return true;
  }
  
  // 여러 필드 업데이트
  updateFields(fields) {
    let hasErrors = false;
    
    for (const [field, value] of Object.entries(fields)) {
      const success = this.updateField(field, value);
      if (!success) hasErrors = true;
    }
    
    return !hasErrors;
  }
  
  // 단일 필드 검증
  validateField(field) {
    const rule = this.validationRules[field];
    const value = this.data[field];
    
    if (!rule) return true;
    
    // 필수 검증
    if (rule.required && (!value || value.toString().trim() === '')) {
      this.errors[field] = rule.requiredMessage || `${field}는 필수 항목입니다.`;
      return false;
    }
    
    // 최소 길이 검증
    if (rule.minLength && value && value.length < rule.minLength) {
      this.errors[field] = rule.minLengthMessage || `${field}는 최소 ${rule.minLength}자 이상이어야 합니다.`;
      return false;
    }
    
    // 최대 길이 검증
    if (rule.maxLength && value && value.length > rule.maxLength) {
      this.errors[field] = rule.maxLengthMessage || `${field}는 최대 ${rule.maxLength}자까지 입력 가능합니다.`;
      return false;
    }
    
    // 정규식 검증
    if (rule.pattern && value && !rule.pattern.test(value)) {
      this.errors[field] = rule.patternMessage || `${field} 형식이 올바르지 않습니다.`;
      return false;
    }
    
    // 커스텀 검증 함수
    if (rule.custom && typeof rule.custom === 'function') {
      const result = rule.custom(value, this.data);
      if (result !== true) {
        this.errors[field] = result || `${field} 값이 유효하지 않습니다.`;
        return false;
      }
    }
    
    // 해당 필드 에러 제거
    if (this.errors[field]) {
      delete this.errors[field];
    }
    
    return true;
  }
  
  // 전체 폼 검증
  validate() {
    this.errors = {};
    let isValid = true;
    
    for (const field of Object.keys(this.validationRules)) {
      if (!this.validateField(field)) {
        isValid = false;
      }
    }
    
    this.updateState();
    return isValid;
  }
  
  // 비동기 검증 (예: 서버 검증)
  async validateAsync(asyncValidator) {
    if (!asyncValidator || typeof asyncValidator !== 'function') {
      return this.validate();
    }
    
    try {
      const result = await asyncValidator(this.data);
      
      if (result === true) {
        return true;
      } else if (typeof result === 'object') {
        // 서버에서 반환된 에러 객체
        this.errors = { ...this.errors, ...result };
        this.updateState();
        return false;
      }
    } catch (error) {
      console.error('비동기 검증 실패:', error);
      return false;
    }
    
    return false;
  }
  
  // 폼 리셋
  reset() {
    this.data = { ...this.initialData };
    this.errors = {};
    this.touched = {};
    this.isDirty = false;
    this.isSubmitting = false;
    this.updateState();
  }
  
  // 특정 필드 리셋
  resetField(field) {
    this.data[field] = this.initialData[field] || '';
    delete this.errors[field];
    delete this.touched[field];
    this.updateState();
  }
  
  // 폼 서밋 상태 설정
  setSubmitting(isSubmitting) {
    this.isSubmitting = isSubmitting;
    this.updateState();
  }
  
  // 상태 변경 알림
  updateState() {
    if (this.onStateChange) {
      this.onStateChange({
        data: this.data,
        errors: this.errors,
        touched: this.touched,
        isDirty: this.isDirty,
        isSubmitting: this.isSubmitting,
        isValid: Object.keys(this.errors).length === 0
      });
    }
  }
  
  // 상태 접근자들
  get isValid() {
    return Object.keys(this.errors).length === 0;
  }
  
  get hasErrors() {
    return Object.keys(this.errors).length > 0;
  }
  
  get errorCount() {
    return Object.keys(this.errors).length;
  }
  
  get touchedCount() {
    return Object.keys(this.touched).length;
  }
  
  // 폼 데이터 초기화
  setInitialData(data) {
    this.initialData = { ...data };
    this.reset();
  }
  
  // 에러 메시지 설정
  setError(field, message) {
    this.errors[field] = message;
    this.updateState();
  }
  
  // 에러 제거
  clearError(field) {
    if (this.errors[field]) {
      delete this.errors[field];
      this.updateState();
    }
  }
  
  // 모든 에러 제거
  clearAllErrors() {
    this.errors = {};
    this.updateState();
  }
}

```

---

## 6.8 서버 상태 관리 (Alpine.js + HTMX)

### 6.8.1 서버 데이터 캐싱 매니저
```javascript
// 서버 데이터 캐싱 및 동기화 관리 (Alpine.js 패턴)
class ServerDataManager {
  constructor() {
    this.cache = new Map(); // 데이터 캐시
    this.loading = new Set(); // 로딩 상태 추적
    this.subscriptions = new Map(); // 실시간 업데이트 구독
    this.staleTime = 5 * 60 * 1000; // 5분 (기본 유효시간)
    this.onDataChange = null; // 데이터 변경 콜백
  }
  
  // 캐시 키 생성
  generateCacheKey(type, ...params) {
    return [type, ...params.filter(p => p !== null && p !== undefined)].join(':');
  }
  
  // 데이터 요청 (HTMX 호환)
  async fetchData(cacheKey, fetchFunction, options = {}) {
    const { 
      forceRefresh = false,
      staleTime = this.staleTime,
      retries = 3 
    } = options;
    
    // 이미 로딩 중인 경우 대기
    if (this.loading.has(cacheKey)) {
      return new Promise((resolve) => {
        const checkInterval = setInterval(() => {
          if (!this.loading.has(cacheKey)) {
            clearInterval(checkInterval);
            resolve(this.cache.get(cacheKey)?.data);
          }
        }, 100);
      });
    }
    
    // 캐시된 데이터 확인
    const cached = this.cache.get(cacheKey);
    if (cached && !forceRefresh && (Date.now() - cached.timestamp < staleTime)) {
      return cached.data;
    }
    
    // 데이터 로딩
    this.loading.add(cacheKey);
    
    let attempt = 0;
    while (attempt < retries) {
      try {
        const data = await fetchFunction();
        
        // UTF-8 검증
        if (!this.validateUTF8(data)) {
          throw new Error('데이터 UTF-8 인코딩 오류');
        }
        
        // 캐시 저장
        this.cache.set(cacheKey, {
          data,
          timestamp: Date.now(),
          error: null
        });
        
        this.loading.delete(cacheKey);
        this.notifyDataChange(cacheKey, data);
        
        return data;
        
      } catch (error) {
        attempt++;
        console.error(`데이터 요청 실패 (${attempt}/${retries}):`, error);
        
        if (attempt >= retries) {
          this.cache.set(cacheKey, {
            data: null,
            timestamp: Date.now(),
            error: error.message || '데이터 로드 실패'
          });
          
          this.loading.delete(cacheKey);
          throw error;
        }
        
        // 재시도 대기 (지수 백오프)
        await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
      }
    }
  }
  
  // UTF-8 검증
  validateUTF8(data) {
    try {
      const jsonString = JSON.stringify(data);
      const encoded = new TextEncoder().encode(jsonString);
      const decoded = new TextDecoder('utf-8', { fatal: true }).decode(encoded);
      return decoded === jsonString;
    } catch (error) {
      console.error('UTF-8 검증 실패:', error);
      return false;
    }
  }
  
  // 데이터 변경 알림
  notifyDataChange(key, data) {
    if (this.onDataChange) {
      this.onDataChange({ key, data });
    }
  }
}

// 전역 서버 데이터 매니저 인스턴스
window.serverDataManager = new ServerDataManager();
```

---

## 📋 **체크리스트**

### Alpine.js 상태 관리 설정
- [ ] Alpine.js 스토어 구현 (Auth, Students, Education, UI)
- [ ] HTMX + Alpine.js 서버 상태 관리 설정
- [ ] 자동저장 유틸리티 구현
- [ ] 폼 상태 관리 클래스 구현
- [ ] 서버 데이터 캐싱 매니저 설정

### 상태 동기화 (Alpine.js + HTMX)
- [ ] 서버-클라이언트 상태 동기화
- [ ] Supabase Realtime 실시간 업데이트 구독
- [ ] 오프라인 상태 처리 (서비스 워커)
- [ ] 에러 상태 관리 및 사용자 알림
- [ ] UTF-8 인코딩 안전성 검증

---

## 6.7 AI 생성 서비스 상태 관리

### 6.7.1 AI 교육계획 생성 상태
```javascript
// Alpine.js AI 교육계획 생성 스토어
Alpine.store('aiEducationPlan', {
  // 생성 상태
  isGenerating: false,
  generatedPlans: {}, // studentId -> plan
  selectedPlan: null,
  
  // 생성 진행 상태
  generationProgress: 0, // 0-100
  currentStep: '',
  
  // 설정
  preferences: {
    complexity: 'medium',
    focusAreas: [],
    includePreviousData: true,
    customInstructions: ''
  },
  
  // 생성 결과 품질
  confidence: 0, // 0-100
  warnings: [],
  suggestions: [],
  
  // 에러 및 재시도
  error: null,
  retryCount: 0,
  
  // UTF-8 인코딩 검증 유틸리티
  validateUTF8(text) {
    try {
      const encoded = new TextEncoder().encode(text);
      const decoded = new TextDecoder('utf-8', { fatal: true }).decode(encoded);
      return decoded === text;
    } catch (error) {
      console.error('UTF-8 인코딩 오류:', error);
      return false;
    }
  },
  
  // 계획 생성
  async generatePlan(params) {
    const { studentId, subject, unit, standards } = params;
    
    // UTF-8 검증
    if (!this.validateUTF8(subject) || !this.validateUTF8(unit)) {
      this.error = '입력 데이터에 인코딩 오류가 있습니다.';
      return;
    }
    
    this.isGenerating = true;
    this.generationProgress = 0;
    this.currentStep = '학생 데이터 수집 중...';
    this.error = null;
    this.retryCount = 0;
    
    try {
      this.generationProgress = 20;
      this.currentStep = '교육과정 데이터 로드 중...';
      
      this.generationProgress = 50;
      this.currentStep = 'AI 계획 생성 중...';
      
      // Supabase Edge Function 호출
      const { data, error } = await supabase.functions.invoke('generate-education-plan', {
        body: {
          studentId,
          subject,
          unit,
          standards,
          teacherPreferences: this.preferences
        }
      });
      
      this.generationProgress = 80;
      this.currentStep = '결과 처리 중...';
      
      if (error) throw error;
      
      if (data && data.success) {
        const plan = data.data;
        this.generatedPlans[studentId] = plan;
        this.selectedPlan = plan;
        this.confidence = plan.confidence || 0;
        this.warnings = plan.warnings || [];
        this.suggestions = plan.suggestions || [];
        this.generationProgress = 100;
        this.currentStep = '완료';
        
        // HTMX로 UI 업데이트 트리거
        document.body.dispatchEvent(new CustomEvent('ai:plan-generated', {
          detail: { studentId, plan }
        }));
      } else {
        throw new Error(data?.error?.message || 'AI 생성 실패');
      }
    } catch (error) {
      this.error = error.message || 'AI 계획 생성 중 오류가 발생했습니다.';
      this.retryCount += 1;
      console.error('AI 계획 생성 오류:', error);
    } finally {
      this.isGenerating = false;
    }
  },
    
    // 계획 관리
    savePlan: async (studentId, plan) => {
      try {
        // API 호출로 저장
        await fetch('/api/education-plans', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ studentId, plan })
        });
        
        set(state => ({
          generatedPlans: {
            ...state.generatedPlans,
            [studentId]: plan
          }
        }));
      } catch (error: any) {
        set({ error: error.message });
      }
    },
    
    loadPlan: async (studentId) => {
      try {
        const response = await fetch(`/api/education-plans/${studentId}`);
        const plan = await response.json();
        
        set(state => ({
          generatedPlans: {
            ...state.generatedPlans,
            [studentId]: plan
          },
          selectedPlan: plan
        }));
      } catch (error: any) {
        set({ error: error.message });
      }
    },
    
    updatePlan: async (studentId, updates) => {
      const currentPlan = get().generatedPlans[studentId];
      if (!currentPlan) return;
      
      const updatedPlan = { ...currentPlan, ...updates };
      await get().savePlan(studentId, updatedPlan);
    },
    
    deletePlan: async (studentId) => {
      try {
        await fetch(`/api/education-plans/${studentId}`, {
          method: 'DELETE'
        });
        
        set(state => {
          const { [studentId]: deleted, ...rest } = state.generatedPlans;
          return {
            generatedPlans: rest,
            selectedPlan: state.selectedPlan?.id === studentId ? null : state.selectedPlan
          };
        });
      } catch (error: any) {
        set({ error: error.message });
      }
    },
    
    // 설정 관리
    updatePreferences: (preferences) => {
      set(state => ({
        preferences: { ...state.preferences, ...preferences }
      }));
    },
    
    loadTemplates: async () => {
      try {
        const response = await fetch('/api/plan-templates');
        const templates = await response.json();
        set({ templates });
      } catch (error: any) {
        set({ error: error.message });
      }
    },
    
    // 상태 초기화
    resetGeneration: () => {
      set({
        isGenerating: false,
        generationProgress: 0,
        currentStep: '',
        confidence: 0,
        warnings: [],
        suggestions: [],
        error: null,
        retryCount: 0
      });
    },
    
    clearError: () => {
      set({ error: null });
    }
  
  // 의견서 승인
  async approveOpinion(studentId, previewContent, confidence) {
    if (!this.validateUTF8(previewContent)) {
      this.error = '의견서 내용에 인코딩 오류가 있습니다.';
      return;
    }
    
    const opinion = {
      id: `opinion_${Date.now()}`,
      studentId,
      content: previewContent,
      confidence,
      createdAt: new Date().toISOString(),
      status: 'approved'
    };
    
    await this.saveOpinion(studentId, opinion);
    this.previewMode = false;
    this.previewContent = '';
  },
  
  // 의견서 거부
  rejectOpinion(studentId) {
    this.previewMode = false;
    this.previewContent = '';
    this.confidence = 0;
  },
  
  // 의견서 저장
  async saveOpinion(studentId, opinion) {
    try {
      const { data, error } = await supabase
        .from('school_opinions')
        .upsert([{
          student_id: studentId,
          content: opinion.content,
          confidence: opinion.confidence,
          status: opinion.status
        }])
        .select();
      
      if (error) throw error;
      
      this.generatedOpinions[studentId] = opinion;
      this.selectedOpinion = opinion;
      
      // HTMX UI 업데이트
      document.body.dispatchEvent(new CustomEvent('ai:opinion-saved', {
        detail: { studentId, opinion }
      }));
    } catch (error) {
      this.error = error.message || '의견서 저장 중 오류가 발생했습니다.';
      console.error('의견서 저장 오류:', error);
    }
  },
  
  // 의견서 로드
  async loadOpinion(studentId) {
    try {
      const { data, error } = await supabase
        .from('school_opinions')
        .select('*')
        .eq('student_id', studentId)
        .single();
      
      if (error && error.code !== 'PGRST116') throw error;
      
      if (data) {
        const opinion = {
          id: data.id,
          studentId: data.student_id,
          content: data.content,
          confidence: data.confidence,
          createdAt: data.created_at,
          status: data.status
        };
        
        this.generatedOpinions[studentId] = opinion;
        this.selectedOpinion = opinion;
      }
    } catch (error) {
      this.error = error.message || '의견서 로드 중 오류가 발생했습니다.';
      console.error('의견서 로드 오류:', error);
    }
  },
  
  // 미리보기 모드 설정
  setPreviewMode(enabled) {
    this.previewMode = enabled;
  },
  
  // 에러 삭제
  clearError() {
    this.error = null;
  }
});
```

### 6.7.3 AI 상담 가이드 상태
```javascript
// Alpine.js AI 상담 가이드 스토어
Alpine.store('aiCounselingGuide', {
  // 생성 상태
  isGenerating: false,
  generatedGuides: {}, // studentId -> guide
  selectedGuide: null,
  
  // 설정
  selectedFocusAreas: [],
  availableFocusAreas: [
    '학습 능력 향상',
    '사회성 발달',
    '의사소통 기술',
    '문제행동 개선',
    '자립생활 기술',
    '진로 탐색',
    '가족 관계',
    '스트레스 관리'
  ],
  
  // 오류 처리
  error: null,
  
  // UTF-8 인코딩 검증
  validateUTF8(text) {
    try {
      const encoded = new TextEncoder().encode(text);
      const decoded = new TextDecoder('utf-8', { fatal: true }).decode(encoded);
      return decoded === text;
    } catch (error) {
      console.error('UTF-8 인코딩 오류:', error);
      return false;
    }
  },
  
  // 가이드 생성
  async generateGuide(params) {
    const { studentId, counselingType, focusAreas } = params;
    
    // UTF-8 검증
    if (focusAreas.some(area => !this.validateUTF8(area))) {
      this.error = '관심 영역 데이터에 인코딩 오류가 있습니다.';
      return;
    }
    
    this.isGenerating = true;
    this.error = null;
    
    try {
      // Supabase Edge Function 호출
      const { data, error } = await supabase.functions.invoke('generate-counseling-guide', {
        body: {
          studentId,
          counselingType,
          focusAreas,
          teacherPreferences: {}
        }
      });
      
      if (error) throw error;
      
      if (data && data.success) {
        const guide = data.data;
        this.generatedGuides[studentId] = guide;
        this.selectedGuide = guide;
        
        // HTMX UI 업데이트
        document.body.dispatchEvent(new CustomEvent('ai:guide-generated', {
          detail: { studentId, guide }
        }));
      } else {
        throw new Error(data?.error?.message || '상담 가이드 생성 실패');
      }
    } catch (error) {
      this.error = error.message || '상담 가이드 생성 중 오류가 발생했습니다.';
      console.error('AI 상담 가이드 생성 오류:', error);
    } finally {
      this.isGenerating = false;
    }
  },
  
  // 가이드 저장
  async saveGuide(studentId, guide) {
    try {
      const { data, error } = await supabase
        .from('counseling_guides')
        .upsert([{
          student_id: studentId,
          counseling_type: guide.counselingType,
          focus_areas: guide.focusAreas,
          content: guide.content,
          recommendations: guide.recommendations
        }])
        .select();
      
      if (error) throw error;
      
      this.generatedGuides[studentId] = guide;
      
      // HTMX UI 업데이트
      document.body.dispatchEvent(new CustomEvent('ai:guide-saved', {
        detail: { studentId, guide }
      }));
    } catch (error) {
      this.error = error.message || '상담 가이드 저장 중 오류가 발생했습니다.';
      console.error('상담 가이드 저장 오류:', error);
    }
  },
  
  // 가이드 로드
  async loadGuide(studentId) {
    try {
      const { data, error } = await supabase
        .from('counseling_guides')
        .select('*')
        .eq('student_id', studentId)
        .single();
      
      if (error && error.code !== 'PGRST116') throw error;
      
      if (data) {
        const guide = {
          id: data.id,
          studentId: data.student_id,
          counselingType: data.counseling_type,
          focusAreas: data.focus_areas,
          content: data.content,
          recommendations: data.recommendations,
          createdAt: data.created_at
        };
        
        this.generatedGuides[studentId] = guide;
        this.selectedGuide = guide;
      }
    } catch (error) {
      this.error = error.message || '상담 가이드 로드 중 오류가 발생했습니다.';
      console.error('상담 가이드 로드 오류:', error);
    }
  },
  
  // 관심 영역 업데이트
  updateFocusAreas(areas) {
    this.selectedFocusAreas = areas.filter(area => this.validateUTF8(area));
  },
  
  // 관심 영역 로드
  async loadFocusAreas() {
    try {
      const { data, error } = await supabase
        .from('counseling_focus_areas')
        .select('name')
        .eq('is_active', true)
        .order('display_order');
      
      if (error) throw error;
      
      this.availableFocusAreas = data.map(item => item.name);
    } catch (error) {
      this.error = error.message || '관심 영역 로드 중 오류가 발생했습니다.';
      console.error('관심 영역 로드 오류:', error);
    }
  },
  
  // 에러 삭제
  clearError() {
    this.error = null;
  }
});
    clearError: () => {
      set({ error: null });
    }
  })
);
```

### 6.7.4 AI 상태 관리 통합 Alpine.js 스토어
```javascript
// AI 상태 관리 통합 Alpine.js 스토어
Alpine.store('aiServices', {
  // 통합 상태
  isAnyGenerating: false,
  errors: [],
  
  // 전체 AI 서비스 로딩 상태 계산
  get isGenerating() {
    return this.$store.aiEducationPlan?.isGenerating || 
           this.$store.aiSchoolOpinion?.isGenerating || 
           this.$store.aiCounselingGuide?.isGenerating || 
           false;
  },
  
  // 전체 에러 상태 계산
  get allErrors() {
    const errors = [];
    
    if (this.$store.aiEducationPlan?.error) {
      errors.push(this.$store.aiEducationPlan.error);
    }
    if (this.$store.aiSchoolOpinion?.error) {
      errors.push(this.$store.aiSchoolOpinion.error);
    }
    if (this.$store.aiCounselingGuide?.error) {
      errors.push(this.$store.aiCounselingGuide.error);
    }
    
    return errors;
  },
  
  // 전체 에러 삭제
  clearAllErrors() {
    if (this.$store.aiEducationPlan) {
      this.$store.aiEducationPlan.clearError();
    }
    if (this.$store.aiSchoolOpinion) {
      this.$store.aiSchoolOpinion.clearError();
    }
    if (this.$store.aiCounselingGuide) {
      this.$store.aiCounselingGuide.clearError();
    }
    this.errors = [];
  },
  
  // 학생별 AI 서비스 데이터 조회
  getStudentAIData(studentId) {
    return {
      educationPlan: this.$store.aiEducationPlan?.generatedPlans?.[studentId] || null,
      schoolOpinion: this.$store.aiSchoolOpinion?.generatedOpinions?.[studentId] || null,
      counselingGuide: this.$store.aiCounselingGuide?.generatedGuides?.[studentId] || null
    };
  },
  
  // 학생별 AI 서비스 데이터 로드
  async loadStudentAIData(studentId) {
    const promises = [];
    
    if (this.$store.aiEducationPlan && this.$store.aiEducationPlan.loadPlan) {
      promises.push(this.$store.aiEducationPlan.loadPlan(studentId));
    }
    if (this.$store.aiSchoolOpinion && this.$store.aiSchoolOpinion.loadOpinion) {
      promises.push(this.$store.aiSchoolOpinion.loadOpinion(studentId));
    }
    if (this.$store.aiCounselingGuide && this.$store.aiCounselingGuide.loadGuide) {
      promises.push(this.$store.aiCounselingGuide.loadGuide(studentId));
    }
    
    try {
      await Promise.all(promises);
      return { success: true };
    } catch (error) {
      console.error('AI 서비스 데이터 로드 실패:', error);
      return { success: false, error: error.message };
    }
  },
  
  // Alpine.js 컴포넌트에서 사용할 헬퍼 함수
  initializeAIServices() {
    // AI 서비스 스토어들이 존재하지 않으면 초기화
    if (!this.$store.aiEducationPlan) {
      console.warn('AI 교육계획 스토어가 초기화되지 않았습니다.');
    }
    if (!this.$store.aiSchoolOpinion) {
      console.warn('AI 학교 의견 스토어가 초기화되지 않았습니다.');
    }
    if (!this.$store.aiCounselingGuide) {
      console.warn('AI 상담 가이드 스토어가 초기화되지 않았습니다.');
    }
  }
});

// Alpine.js 컴포넌트에서 사용하는 데이터 패턴
Alpine.data('aiServicesManager', () => ({
  get aiServices() {
    return this.$store.aiServices;
  },
  
  get hasAnyErrors() {
    return this.aiServices.allErrors.length > 0;
  },
  
  get isLoading() {
    return this.aiServices.isGenerating;
  },
  
  init() {
    this.aiServices.initializeAIServices();
  },
  
  async loadStudentData(studentId) {
    if (!studentId) return;
    
    const result = await this.aiServices.loadStudentAIData(studentId);
    if (!result.success) {
      this.showError('AI 서비스 데이터 로드에 실패했습니다: ' + result.error);
    }
  },
  
  showError(message) {
    // 에러 표시 로직 (알림 등)
    if (this.$store.notifications) {
      this.$store.notifications.add({
        type: 'error',
        message: message,
        duration: 5000
      });
    } else {
      alert(message);
    }
  }
}));
```

---

## 6.8 관리자 시스템 상태 관리

### 6.8.1 관리자 대시보드 상태

**Alpine.js 관리자 대시보드 스토어**
```javascript
/**
 * @typedef {Object} AdminStatistics - 관리자 통계 정보
 * @property {number} totalUsers - 전체 사용자 수
 * @property {number} activeUsers - 활성 사용자 수
 * @property {number} totalStudents - 전체 학생 수
 * @property {number} recentLogins - 최근 로그인 수
 */

/**
 * @typedef {Object} UserProfile - 사용자 프로필 정보
 * @property {string} id - 사용자 ID
 * @property {string} email - 이메일
 * @property {string} role - 역할 (admin, teacher, student)
 * @property {boolean} is_active - 활성 상태
 * @property {string} created_at - 생성일시
 */

/**
 * @typedef {Object} SystemSetting - 시스템 설정 정보
 * @property {string} setting_key - 설정 키
 * @property {any} setting_value - 설정 값
 * @property {string} description - 설명
 */

// Alpine.js 관리자 대시보드 글로벌 스토어
Alpine.store('adminDashboard', {
  // 통계 데이터
  statistics: null,
  isLoadingStats: false,
  
  // 사용자 관리
  users: [],
  isLoadingUsers: false,
  userFilters: {
    search: '',
    role: 'all',
    status: 'all'
  },
  
  // 시스템 설정
  systemSettings: [],
  isLoadingSettings: false,
  
  // 에러 처리
  error: null,
  
  // 계산된 속성들
  get filteredUsers() {
    return this.users.filter(user => {
      const matchesSearch = !this.userFilters.search || 
        user.email.toLowerCase().includes(this.userFilters.search.toLowerCase());
      
      const matchesRole = this.userFilters.role === 'all' || 
        user.role === this.userFilters.role;
      
      const matchesStatus = this.userFilters.status === 'all' || 
        (this.userFilters.status === 'active' && user.is_active) ||
        (this.userFilters.status === 'inactive' && !user.is_active);
      
      return matchesSearch && matchesRole && matchesStatus;
    });
  },
  
  get isLoading() {
    return this.isLoadingStats || this.isLoadingUsers || this.isLoadingSettings;
  },
  
  // 통계 데이터 로드
  async loadStatistics() {
    this.isLoadingStats = true;
    this.error = null;
    
    try {
      const response = await fetch('/api/admin/statistics', {
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${Alpine.store('auth').user?.access_token}`
        }
      });
      
      if (!response.ok) {
        throw new Error('통계 데이터 로드에 실패했습니다.');
      }
      
      this.statistics = await response.json();
    } catch (error) {
      this.error = error.message;
      console.error('통계 로드 오류:', error);
    } finally {
      this.isLoadingStats = false;
    }
  },
  
  // 사용자 로드
  async loadUsers() {
    this.isLoadingUsers = true;
    this.error = null;
    
    try {
      const response = await fetch('/api/admin/users', {
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${Alpine.store('auth').user?.access_token}`
        }
      });
      
      if (!response.ok) {
        throw new Error('사용자 데이터 로드에 실패했습니다.');
      }
      
      this.users = await response.json();
    } catch (error) {
      this.error = error.message;
      console.error('사용자 로드 오류:', error);
    } finally {
      this.isLoadingUsers = false;
    }
  },
  
  // 사용자 역할 변경
  async updateUserRole(userId, newRole) {
    try {
      const response = await fetch(`/api/admin/users/${userId}/role`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${Alpine.store('auth').user?.access_token}`
        },
        body: JSON.stringify({ role: newRole })
      });
      
      if (!response.ok) {
        throw new Error('사용자 역할 변경에 실패했습니다.');
      }
      
      // 사용자 목록에서 해당 사용자 업데이트
      const userIndex = this.users.findIndex(user => user.id === userId);
      if (userIndex !== -1) {
        this.users[userIndex].role = newRole;
      }
      
      // 성공 알림
      Alpine.store('ui').showNotification('사용자 역할이 성공적으로 변경되었습니다.', 'success');
      
    } catch (error) {
      this.error = error.message;
      console.error('역할 변경 오류:', error);
    }
  },
  
  // 사용자 활성/비활성 토글
  async toggleUserActive(userId) {
    try {
      const user = this.users.find(u => u.id === userId);
      if (!user) return;
      
      const response = await fetch(`/api/admin/users/${userId}/toggle-active`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${Alpine.store('auth').user?.access_token}`
        }
      });
      
      if (!response.ok) {
        throw new Error('사용자 상태 변경에 실패했습니다.');
      }
      
      // 사용자 목록에서 해당 사용자 상태 업데이트
      const userIndex = this.users.findIndex(u => u.id === userId);
      if (userIndex !== -1) {
        this.users[userIndex].is_active = !this.users[userIndex].is_active;
      }
      
      // 성공 알림
      const status = user.is_active ? '비활성화' : '활성화';
      Alpine.store('ui').showNotification(`사용자가 성공적으로 ${status}되었습니다.`, 'success');
      
    } catch (error) {
      this.error = error.message;
      console.error('사용자 상태 변경 오류:', error);
    }
  },
  
  // 사용자 필터 설정
  setUserFilters(filters) {
    this.userFilters = { ...this.userFilters, ...filters };
  },
  
  // 시스템 설정 로드
  async loadSystemSettings() {
    this.isLoadingSettings = true;
    this.error = null;
    
    try {
      const response = await fetch('/api/admin/system-settings', {
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${Alpine.store('auth').user?.access_token}`
        }
      });
      
      if (!response.ok) {
        throw new Error('시스템 설정 로드에 실패했습니다.');
      }
      
      this.systemSettings = await response.json();
    } catch (error) {
      this.error = error.message;
      console.error('시스템 설정 로드 오류:', error);
    } finally {
      this.isLoadingSettings = false;
    }
  },
  
  // 시스템 설정 업데이트
  async updateSystemSetting(key, value) {
    try {
      const response = await fetch(`/api/admin/system-settings/${key}`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${Alpine.store('auth').user?.access_token}`
        },
        body: JSON.stringify({ value })
      });
      
      if (!response.ok) {
        throw new Error('시스템 설정 업데이트에 실패했습니다.');
      }
      
      // 설정 목록에서 해당 설정 업데이트
      const settingIndex = this.systemSettings.findIndex(
        setting => setting.setting_key === key
      );
      if (settingIndex !== -1) {
        this.systemSettings[settingIndex].setting_value = value;
      }
      
      // 성공 알림
      Alpine.store('ui').showNotification('시스템 설정이 성공적으로 업데이트되었습니다.', 'success');
      
    } catch (error) {
      this.error = error.message;
      console.error('시스템 설정 업데이트 오류:', error);
    }
  },
  
  // 에러 설정
  setError(error) {
    this.error = error;
  },
  
  // 에러 초기화
  clearError() {
    this.error = null;
  },
  
  // 전체 데이터 초기화
  reset() {
    this.statistics = null;
    this.users = [];
    this.systemSettings = [];
    this.userFilters = { search: '', role: 'all', status: 'all' };
    this.error = null;
    this.isLoadingStats = false;
    this.isLoadingUsers = false;
    this.isLoadingSettings = false;
  }
});

// Alpine.js 관리자 대시보드 컴포넌트 데이터
Alpine.data('adminDashboardComponent', () => ({
  // 현재 활성 탭
  activeTab: 'statistics',
  
  // 탭 변경
  setActiveTab(tab) {
    this.activeTab = tab;
    
    // 탭별 데이터 로드
    const store = Alpine.store('adminDashboard');
    switch (tab) {
      case 'statistics':
        if (!store.statistics) store.loadStatistics();
        break;
      case 'users':
        if (store.users.length === 0) store.loadUsers();
        break;
      case 'settings':
        if (store.systemSettings.length === 0) store.loadSystemSettings();
        break;
    }
  },
  
  // 초기화 시 실행
  init() {
    // 페이지 로드 시 통계 데이터 자동 로드
    Alpine.store('adminDashboard').loadStatistics();
  }
}));
```

### 6.8.2 알림 시스템 상태

**Alpine.js 알림 시스템 스토어**
```javascript
/**
 * @typedef {Object} Notification - 알림 정보
 * @property {string} id - 알림 ID
 * @property {string} title - 제목
 * @property {string} message - 내용
 * @property {string} type - 유형 (info, success, warning, error)
 * @property {boolean} is_read - 읽음 여부
 * @property {string} user_id - 대상 사용자 ID
 * @property {string} created_at - 생성일시
 * @property {string|null} action_url - 액션 URL
 */

// Alpine.js 알림 시스템 글로벌 스토어
Alpine.store('notifications', {
  // 알림 데이터
  notifications: [],
  unreadCount: 0,
  isLoading: false,
  isOpen: false,
  error: null,
  
  // 알림 자동 새로고침 상태
  autoRefresh: true,
  refreshInterval: null,
  
  // 계산된 속성들
  get recentNotifications() {
    return this.notifications
      .sort((a, b) => new Date(b.created_at) - new Date(a.created_at))
      .slice(0, 10); // 최근 10개만 표시
  },
  
  get unreadNotifications() {
    return this.notifications.filter(n => !n.is_read);
  },
  
  get hasUnread() {
    return this.unreadCount > 0;
  },
  
  // 알림 로드
  async loadNotifications() {
    this.isLoading = true;
    this.error = null;
    
    try {
      const response = await fetch('/api/notifications', {
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${Alpine.store('auth').user?.access_token}`
        }
      });
      
      if (!response.ok) {
        throw new Error('알림 데이터 로드에 실패했습니다.');
      }
      
      this.notifications = await response.json();
      this.unreadCount = this.notifications.filter(n => !n.is_read).length;
      
    } catch (error) {
      this.error = error.message;
      console.error('알림 로드 오류:', error);
    } finally {
      this.isLoading = false;
    }
  },
  
  // 알림 읽음 처리
  async markAsRead(notificationId) {
    try {
      const response = await fetch(`/api/notifications/${notificationId}/read`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${Alpine.store('auth').user?.access_token}`
        }
      });
      
      if (!response.ok) {
        throw new Error('알림 읽음 처리에 실패했습니다.');
      }
      
      // 로컬 상태 업데이트
      const notificationIndex = this.notifications.findIndex(n => n.id === notificationId);
      if (notificationIndex !== -1 && !this.notifications[notificationIndex].is_read) {
        this.notifications[notificationIndex].is_read = true;
        this.unreadCount = Math.max(0, this.unreadCount - 1);
      }
      
    } catch (error) {
      this.error = error.message;
      console.error('알림 읽음 처리 오류:', error);
    }
  },
  
  // 모든 알림 읽음 처리
  async markAllAsRead() {
    if (this.unreadCount === 0) return;
    
    try {
      const response = await fetch('/api/notifications/read-all', {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${Alpine.store('auth').user?.access_token}`
        }
      });
      
      if (!response.ok) {
        throw new Error('모든 알림 읽음 처리에 실패했습니다.');
      }
      
      // 모든 알림을 읽음 상태로 변경
      this.notifications = this.notifications.map(n => ({ ...n, is_read: true }));
      this.unreadCount = 0;
      
      // 성공 알림
      Alpine.store('ui').showNotification('모든 알림을 읽음 처리했습니다.', 'success');
      
    } catch (error) {
      this.error = error.message;
      console.error('모든 알림 읽음 처리 오류:', error);
    }
  },
  
  // 알림 삭제
  async deleteNotification(notificationId) {
    try {
      const response = await fetch(`/api/notifications/${notificationId}`, {
        method: 'DELETE',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${Alpine.store('auth').user?.access_token}`
        }
      });
      
      if (!response.ok) {
        throw new Error('알림 삭제에 실패했습니다.');
      }
      
      // 로컬 상태에서 알림 제거
      const notification = this.notifications.find(n => n.id === notificationId);
      if (notification && !notification.is_read) {
        this.unreadCount = Math.max(0, this.unreadCount - 1);
      }
      
      this.notifications = this.notifications.filter(n => n.id !== notificationId);
      
      // 성공 알림
      Alpine.store('ui').showNotification('알림이 삭제되었습니다.', 'success');
      
    } catch (error) {
      this.error = error.message;
      console.error('알림 삭제 오류:', error);
    }
  },
  
  // 새 알림 발송
  async sendNotification(notificationData) {
    try {
      const response = await fetch('/api/notifications', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${Alpine.store('auth').user?.access_token}`
        },
        body: JSON.stringify(notificationData)
      });
      
      if (!response.ok) {
        throw new Error('알림 발송에 실패했습니다.');
      }
      
      // 새 알림 로드
      await this.loadNotifications();
      
      // 성공 알림
      Alpine.store('ui').showNotification('알림이 성공적으로 발송되었습니다.', 'success');
      
    } catch (error) {
      this.error = error.message;
      console.error('알림 발송 오류:', error);
    }
  },
  
  // 알림 패널 토글
  toggleNotificationPanel() {
    this.isOpen = !this.isOpen;
    
    // 패널이 열릴 때 알림 로드
    if (this.isOpen && this.notifications.length === 0) {
      this.loadNotifications();
    }
  },
  
  // 알림 패널 열기/닫기
  setOpen(isOpen) {
    this.isOpen = isOpen;
    
    // 패널이 열릴 때 알림 로드
    if (isOpen && this.notifications.length === 0) {
      this.loadNotifications();
    }
  },
  
  // 자동 새로고침 시작
  startAutoRefresh() {
    if (this.refreshInterval) return;
    
    this.autoRefresh = true;
    this.refreshInterval = setInterval(() => {
      if (!document.hidden) { // 탭이 활성 상태일 때만 새로고침
        this.loadNotifications();
      }
    }, 30000); // 30초마다 새로고침
  },
  
  // 자동 새로고침 중지
  stopAutoRefresh() {
    if (this.refreshInterval) {
      clearInterval(this.refreshInterval);
      this.refreshInterval = null;
    }
    this.autoRefresh = false;
  },
  
  // 에러 초기화
  clearError() {
    this.error = null;
  },
  
  // 전체 데이터 초기화
  reset() {
    this.stopAutoRefresh();
    this.notifications = [];
    this.unreadCount = 0;
    this.isOpen = false;
    this.error = null;
    this.isLoading = false;
  }
});

// Alpine.js 알림 패널 컴포넌트 데이터
Alpine.data('notificationPanel', () => ({
  // 현재 표시 모드 (전체/읽지않음)
  viewMode: 'all',
  
  // 보기 모드 변경
  setViewMode(mode) {
    this.viewMode = mode;
  },
  
  // 표시할 알림 목록
  get displayNotifications() {
    const store = Alpine.store('notifications');
    
    if (this.viewMode === 'unread') {
      return store.unreadNotifications;
    }
    
    return store.recentNotifications;
  },
  
  // 알림 클릭 처리
  async handleNotificationClick(notification) {
    // 알림을 읽음으로 처리
    if (!notification.is_read) {
      await Alpine.store('notifications').markAsRead(notification.id);
    }
    
    // 액션 URL이 있으면 이동
    if (notification.action_url) {
      window.location.href = notification.action_url;
    }
  },
  
  // 초기화 시 실행
  init() {
    // 컴포넌트 생성 시 자동 새로고침 시작
    Alpine.store('notifications').startAutoRefresh();
    
    // 컴포넌트 파괴 시 정리
    this.$cleanup(() => {
      Alpine.store('notifications').stopAutoRefresh();
    });
  }
}));
```

### 6.8.3 로그인 기록 상태

**Alpine.js 로그인 기록 스토어**
```javascript
/**
 * @typedef {Object} AdminLoginLog - 관리자 로그인 기록
 * @property {string} id - 로그 ID
 * @property {string} user_id - 사용자 ID
 * @property {string} user_email - 사용자 이메일
 * @property {string} login_type - 로그인 유형 (email, social, admin)
 * @property {string} ip_address - IP 주소
 * @property {string} user_agent - 브라우저 정보
 * @property {string} login_at - 로그인 시간
 * @property {boolean} success - 성공 여부
 * @property {string|null} failure_reason - 실패 사유
 */

// Alpine.js 로그인 기록 글로벌 스토어
Alpine.store('loginLogs', {
  // 로그 데이터
  logs: [],
  isLoading: false,
  error: null,
  
  // 필터 설정
  filters: {
    dateRange: {
      start: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0], // 30일 전
      end: new Date().toISOString().split('T')[0] // 오늘
    },
    loginType: 'all', // all, email, social, admin
    searchTerm: '',
    successOnly: false // 성공한 로그인만 표시
  },
  
  // 페이지네이션
  pagination: {
    page: 1,
    limit: 20,
    total: 0
  },
  
  // 계산된 속성들
  get filteredLogs() {
    let filtered = [...this.logs];
    
    // 검색어 필터
    if (this.filters.searchTerm) {
      const term = this.filters.searchTerm.toLowerCase();
      filtered = filtered.filter(log => 
        log.user_email.toLowerCase().includes(term) ||
        log.ip_address.includes(term)
      );
    }
    
    // 로그인 유형 필터
    if (this.filters.loginType !== 'all') {
      filtered = filtered.filter(log => log.login_type === this.filters.loginType);
    }
    
    // 성공 로그인만 표시
    if (this.filters.successOnly) {
      filtered = filtered.filter(log => log.success);
    }
    
    return filtered;
  },
  
  get totalPages() {
    return Math.ceil(this.pagination.total / this.pagination.limit);
  },
  
  get hasNextPage() {
    return this.pagination.page < this.totalPages;
  },
  
  get hasPrevPage() {
    return this.pagination.page > 1;
  },
  
  // 로그 로드
  async loadLogs() {
    this.isLoading = true;
    this.error = null;
    
    try {
      const params = new URLSearchParams({
        page: this.pagination.page.toString(),
        limit: this.pagination.limit.toString(),
        startDate: this.filters.dateRange.start,
        endDate: this.filters.dateRange.end,
        loginType: this.filters.loginType,
        search: this.filters.searchTerm,
        successOnly: this.filters.successOnly.toString()
      });
      
      const response = await fetch(`/api/admin/login-logs?${params}`, {
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${Alpine.store('auth').user?.access_token}`
        }
      });
      
      if (!response.ok) {
        throw new Error('로그인 기록 로드에 실패했습니다.');
      }
      
      const { data, total } = await response.json();
      
      this.logs = data;
      this.pagination.total = total;
      
    } catch (error) {
      this.error = error.message;
      console.error('로그인 기록 로드 오류:', error);
    } finally {
      this.isLoading = false;
    }
  },
  
  // 필터 설정
  setFilters(newFilters) {
    this.filters = { ...this.filters, ...newFilters };
    this.pagination.page = 1; // 필터 변경 시 첫 페이지로
    
    // 자동으로 로그 다시 로드
    this.loadLogs();
  },
  
  // 날짜 범위 설정
  setDateRange(start, end) {
    this.filters.dateRange = { start, end };
    this.pagination.page = 1;
    this.loadLogs();
  },
  
  // 미리 정의된 날짜 범위 설정
  setDateRangePreset(preset) {
    const now = new Date();
    let start;
    
    switch (preset) {
      case 'today':
        start = new Date(now);
        break;
      case 'week':
        start = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
        break;
      case 'month':
        start = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
        break;
      case 'quarter':
        start = new Date(now.getTime() - 90 * 24 * 60 * 60 * 1000);
        break;
      default:
        start = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
    }
    
    this.setDateRange(
      start.toISOString().split('T')[0],
      now.toISOString().split('T')[0]
    );
  },
  
  // 페이지 설정
  setPage(page) {
    if (page < 1 || page > this.totalPages) return;
    
    this.pagination.page = page;
    this.loadLogs();
  },
  
  // 이전 페이지
  previousPage() {
    if (this.hasPrevPage) {
      this.setPage(this.pagination.page - 1);
    }
  },
  
  // 다음 페이지
  nextPage() {
    if (this.hasNextPage) {
      this.setPage(this.pagination.page + 1);
    }
  },
  
  // 페이지 크기 설정
  setLimit(limit) {
    this.pagination.limit = limit;
    this.pagination.page = 1; // 첫 페이지로 재설정
    this.loadLogs();
  },
  
  // 로그 내보내기 (CSV)
  async exportLogs() {
    try {
      const params = new URLSearchParams({
        startDate: this.filters.dateRange.start,
        endDate: this.filters.dateRange.end,
        loginType: this.filters.loginType,
        search: this.filters.searchTerm,
        successOnly: this.filters.successOnly.toString(),
        format: 'csv'
      });
      
      const response = await fetch(`/api/admin/login-logs/export?${params}`, {
        headers: {
          'Authorization': `Bearer ${Alpine.store('auth').user?.access_token}`
        }
      });
      
      if (!response.ok) {
        throw new Error('로그 내보내기에 실패했습니다.');
      }
      
      // 파일 다운로드 처리
      const blob = await response.blob();
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `login-logs-${this.filters.dateRange.start}-${this.filters.dateRange.end}.csv`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      window.URL.revokeObjectURL(url);
      
      // 성공 알림
      Alpine.store('ui').showNotification('로그인 기록이 CSV 파일로 내보내졌습니다.', 'success');
      
    } catch (error) {
      this.error = error.message;
      console.error('로그 내보내기 오류:', error);
    }
  },
  
  // 에러 초기화
  clearError() {
    this.error = null;
  },
  
  // 전체 데이터 초기화
  reset() {
    this.logs = [];
    this.pagination = { page: 1, limit: 20, total: 0 };
    this.filters = {
      dateRange: {
        start: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
        end: new Date().toISOString().split('T')[0]
      },
      loginType: 'all',
      searchTerm: '',
      successOnly: false
    };
    this.error = null;
    this.isLoading = false;
  }
});

// Alpine.js 로그인 기록 컴포넌트 데이터
Alpine.data('loginLogsComponent', () => ({
  // 날짜 선택기 열기/닫기
  isDatePickerOpen: false,
  
  // 날짜 선택기 토글
  toggleDatePicker() {
    this.isDatePickerOpen = !this.isDatePickerOpen;
  },
  
  // 로그 유형별 배지 색상
  getLoginTypeBadgeClass(loginType) {
    const classes = {
      'email': 'badge-primary',
      'social': 'badge-success', 
      'admin': 'badge-warning'
    };
    return classes[loginType] || 'badge-secondary';
  },
  
  // 로그인 성공/실패 아이콘
  getStatusIcon(success) {
    return success ? '✓' : '✗';
  },
  
  // 로그인 성공/실패 색상
  getStatusClass(success) {
    return success ? 'text-success' : 'text-danger';
  },
  
  // IP 주소 포맷팅
  formatIPAddress(ip) {
    // IPv4 주소 검증 및 포맷팅
    const ipv4Regex = /^(\d{1,3}\.){3}\d{1,3}$/;
    if (ipv4Regex.test(ip)) {
      return ip;
    }
    
    // IPv6 주소 간단히 표시
    if (ip.includes(':')) {
      return ip.substring(0, 20) + (ip.length > 20 ? '...' : '');
    }
    
    return ip;
  },
  
  // 사용자 에이전트 간단히 표시
  formatUserAgent(userAgent) {
    if (!userAgent) return '알 수 없음';
    
    // 주요 브라우저 이름 추출
    if (userAgent.includes('Chrome')) return 'Chrome';
    if (userAgent.includes('Firefox')) return 'Firefox';
    if (userAgent.includes('Safari')) return 'Safari';
    if (userAgent.includes('Edge')) return 'Edge';
    
    return userAgent.substring(0, 30) + (userAgent.length > 30 ? '...' : '');
  },
  
  // 초기화 시 실행
  init() {
    // 컴포넌트 로드 시 로그 데이터 자동 로드
    Alpine.store('loginLogs').loadLogs();
  }
}));
```

### 6.8.4 관리자 상태 활용 예시
```html
<!-- 관리자 대시보드 HTML + Alpine.js -->
<div class="admin-dashboard" 
     x-data="adminDashboard()" 
     x-init="init()">
  
  <!-- 에러 처리 -->
  <div x-show="error" 
       x-transition
       class="alert alert-error mb-4"
       role="alert">
    <span x-text="error"></span>
    <button @click="clearError()" 
            class="btn-close"
            aria-label="오류 메시지 닫기">
      ✕
    </button>
  </div>
  
  <div class="space-y-6">
    <!-- 통계 카드 -->
    <div x-show="isLoadingStats" 
         class="stats-skeleton" 
         role="status" 
         aria-label="통계 로딩 중">
      <div class="skeleton-card"></div>
      <div class="skeleton-card"></div>
      <div class="skeleton-card"></div>
    </div>
    
    <div x-show="!isLoadingStats" 
         class="stats-grid">
      <template x-for="stat in statistics">
        <div class="stat-card">
          <h3 x-text="stat.title"></h3>
          <span x-text="stat.value" class="stat-value"></span>
        </div>
      </template>
    </div>
    
    <!-- 사용자 관리 테이블 -->
    <div class="user-management-section">
      <h2>사용자 관리</h2>
      
      <div x-show="isLoadingUsers" 
           class="loading-indicator"
           role="status" 
           aria-label="사용자 목록 로딩 중">
        <div class="spinner"></div>
      </div>
      
      <table x-show="!isLoadingUsers" 
             class="user-table table-responsive"
             role="table">
        <thead>
          <tr>
            <th>이름</th>
            <th>이메일</th>
            <th>역할</th>
            <th>상태</th>
            <th>액션</th>
          </tr>
        </thead>
        <tbody>
          <template x-for="user in users" :key="user.id">
            <tr>
              <td x-text="user.name"></td>
              <td x-text="user.email"></td>
              <td>
                <select @change="updateUserRole(user.id, $event.target.value)"
                        :value="user.role"
                        class="role-select">
                  <option value="user">사용자</option>
                  <option value="admin">관리자</option>
                  <option value="teacher">교사</option>
                </select>
              </td>
              <td>
                <span :class="user.active ? 'badge-active' : 'badge-inactive'"
                      x-text="user.active ? '활성' : '비활성'"></span>
              </td>
              <td>
                <button @click="toggleUserActive(user.id)"
                        :class="user.active ? 'btn-deactivate' : 'btn-activate'"
                        :aria-label="user.active ? user.name + ' 비활성화' : user.name + ' 활성화'">
                  <span x-text="user.active ? '비활성화' : '활성화'"></span>
                </button>
              </td>
            </tr>
          </template>
        </tbody>
      </table>
    </div>
    
    <!-- 알림 센터 -->
    <div class="notification-center">
      <h2>알림 센터 
        <span x-show="unreadCount > 0" 
              x-text="'(' + unreadCount + ')'"
              class="unread-badge"
              aria-label="읽지 않은 알림 수"></span>
      </h2>
      
      <div class="notification-actions">
        <button @click="markAllAsRead()" 
                :disabled="unreadCount === 0"
                class="btn btn-outline">
          모두 읽음 처리
        </button>
      </div>
      
      <div class="notifications-list">
        <template x-for="notification in notifications" :key="notification.id">
          <div :class="['notification-item', { 'unread': !notification.read }]">
            <div class="notification-content">
              <p x-text="notification.message"></p>
              <small x-text="formatDate(notification.created_at)" 
                     class="notification-date"></small>
            </div>
            <div class="notification-actions">
              <button x-show="!notification.read" 
                      @click="markAsRead(notification.id)"
                      class="btn-read"
                      :aria-label="'알림 읽음 처리: ' + notification.message">
                읽음
              </button>
              <button @click="deleteNotification(notification.id)"
                      class="btn-delete"
                      :aria-label="'알림 삭제: ' + notification.message">
                삭제
              </button>
            </div>
          </div>
        </template>
      </div>
    </div>
  </div>
</div>

<script>
// 관리자 대시보드 Alpine.js 데이터 함수
function adminDashboard() {
  return {
    // 상태 데이터
    statistics: [],
    users: [],
    notifications: [],
    
    // 로딩 상태
    isLoadingStats: false,
    isLoadingUsers: false,
    
    // 알림 관련
    unreadCount: 0,
    
    // 에러 처리
    error: null,
    
    // 초기화 함수
    async init() {
      try {
        await Promise.all([
          this.loadStatistics(),
          this.loadUsers(),
          this.loadNotifications()
        ]);
      } catch (error) {
        this.error = '데이터 로드 중 오류가 발생했습니다: ' + error.message;
      }
    },
    
    // 통계 데이터 로드
    async loadStatistics() {
      this.isLoadingStats = true;
      try {
        const response = await fetch('/api/admin/statistics', {
          headers: {
            'Authorization': `Bearer ${localStorage.getItem('token')}`,
            'Content-Type': 'application/json'
          }
        });
        
        if (!response.ok) {
          throw new Error('통계 데이터를 불러올 수 없습니다');
        }
        
        this.statistics = await response.json();
      } catch (error) {
        this.error = error.message;
      } finally {
        this.isLoadingStats = false;
      }
    },
    
    // 사용자 목록 로드
    async loadUsers() {
      this.isLoadingUsers = true;
      try {
        const response = await fetch('/api/admin/users', {
          headers: {
            'Authorization': `Bearer ${localStorage.getItem('token')}`,
            'Content-Type': 'application/json'
          }
        });
        
        if (!response.ok) {
          throw new Error('사용자 목록을 불러올 수 없습니다');
        }
        
        this.users = await response.json();
      } catch (error) {
        this.error = error.message;
      } finally {
        this.isLoadingUsers = false;
      }
    },
    
    // 알림 목록 로드
    async loadNotifications() {
      try {
        const response = await fetch('/api/admin/notifications', {
          headers: {
            'Authorization': `Bearer ${localStorage.getItem('token')}`,
            'Content-Type': 'application/json'
          }
        });
        
        if (!response.ok) {
          throw new Error('알림을 불러올 수 없습니다');
        }
        
        this.notifications = await response.json();
        this.unreadCount = this.notifications.filter(n => !n.read).length;
      } catch (error) {
        this.error = error.message;
      }
    },
    
    // 사용자 역할 업데이트
    async updateUserRole(userId, newRole) {
      try {
        const response = await fetch(`/api/admin/users/${userId}/role`, {
          method: 'PUT',
          headers: {
            'Authorization': `Bearer ${localStorage.getItem('token')}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ role: newRole })
        });
        
        if (!response.ok) {
          throw new Error('사용자 역할 변경에 실패했습니다');
        }
        
        // 로컬 상태 업데이트
        const userIndex = this.users.findIndex(u => u.id === userId);
        if (userIndex !== -1) {
          this.users[userIndex].role = newRole;
        }
      } catch (error) {
        this.error = error.message;
      }
    },
    
    // 사용자 활성 상태 토글
    async toggleUserActive(userId) {
      try {
        const user = this.users.find(u => u.id === userId);
        const newStatus = !user.active;
        
        const response = await fetch(`/api/admin/users/${userId}/status`, {
          method: 'PUT',
          headers: {
            'Authorization': `Bearer ${localStorage.getItem('token')}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ active: newStatus })
        });
        
        if (!response.ok) {
          throw new Error('사용자 상태 변경에 실패했습니다');
        }
        
        // 로컬 상태 업데이트
        user.active = newStatus;
      } catch (error) {
        this.error = error.message;
      }
    },
    
    // 알림 읽음 처리
    async markAsRead(notificationId) {
      try {
        const response = await fetch(`/api/admin/notifications/${notificationId}/read`, {
          method: 'PUT',
          headers: {
            'Authorization': `Bearer ${localStorage.getItem('token')}`,
            'Content-Type': 'application/json'
          }
        });
        
        if (!response.ok) {
          throw new Error('알림 읽음 처리에 실패했습니다');
        }
        
        // 로컬 상태 업데이트
        const notification = this.notifications.find(n => n.id === notificationId);
        if (notification && !notification.read) {
          notification.read = true;
          this.unreadCount--;
        }
      } catch (error) {
        this.error = error.message;
      }
    },
    
    // 모든 알림 읽음 처리
    async markAllAsRead() {
      try {
        const response = await fetch('/api/admin/notifications/read-all', {
          method: 'PUT',
          headers: {
            'Authorization': `Bearer ${localStorage.getItem('token')}`,
            'Content-Type': 'application/json'
          }
        });
        
        if (!response.ok) {
          throw new Error('모든 알림 읽음 처리에 실패했습니다');
        }
        
        // 로컬 상태 업데이트
        this.notifications.forEach(n => n.read = true);
        this.unreadCount = 0;
      } catch (error) {
        this.error = error.message;
      }
    },
    
    // 알림 삭제
    async deleteNotification(notificationId) {
      try {
        const response = await fetch(`/api/admin/notifications/${notificationId}`, {
          method: 'DELETE',
          headers: {
            'Authorization': `Bearer ${localStorage.getItem('token')}`,
            'Content-Type': 'application/json'
          }
        });
        
        if (!response.ok) {
          throw new Error('알림 삭제에 실패했습니다');
        }
        
        // 로컬 상태 업데이트
        const notificationIndex = this.notifications.findIndex(n => n.id === notificationId);
        if (notificationIndex !== -1) {
          const notification = this.notifications[notificationIndex];
          this.notifications.splice(notificationIndex, 1);
          if (!notification.read) {
            this.unreadCount--;
          }
        }
      } catch (error) {
        this.error = error.message;
      }
    },
    
    // 에러 메시지 클리어
    clearError() {
      this.error = null;
    },
    
    // 날짜 포맷팅 유틸리티
    formatDate(dateString) {
      return new Date(dateString).toLocaleString('ko-KR', {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit'
      });
    }
  };
}
</script>

<!-- 로그인 기록 뷰어 HTML + Alpine.js -->
<div class="login-log-viewer" 
     x-data="loginLogViewer()" 
     x-init="init()">
  
  <!-- 에러 처리 -->
  <div x-show="error" 
       x-transition
       class="alert alert-error mb-4"
       role="alert">
    <span x-text="error"></span>
    <button @click="clearError()" 
            class="btn-close"
            aria-label="오류 메시지 닫기">
      ✕
    </button>
  </div>
  
  <div class="space-y-4">
    <!-- 필터 섹션 -->
    <div class="log-filters">
      <h2>로그인 기록 필터</h2>
      
      <div class="filter-controls">
        <div class="filter-item">
          <label for="user-filter">사용자:</label>
          <input type="text" 
                 id="user-filter"
                 x-model="filters.user"
                 @input="debounceFilter()"
                 placeholder="사용자명 또는 이메일로 검색"
                 class="filter-input">
        </div>
        
        <div class="filter-item">
          <label for="date-from">시작일:</label>
          <input type="date" 
                 id="date-from"
                 x-model="filters.dateFrom"
                 @change="applyFilters()"
                 class="filter-input">
        </div>
        
        <div class="filter-item">
          <label for="date-to">종료일:</label>
          <input type="date" 
                 id="date-to"
                 x-model="filters.dateTo"
                 @change="applyFilters()"
                 class="filter-input">
        </div>
        
        <div class="filter-item">
          <label for="status-filter">상태:</label>
          <select id="status-filter"
                  x-model="filters.status"
                  @change="applyFilters()"
                  class="filter-input">
            <option value="">전체</option>
            <option value="success">성공</option>
            <option value="failed">실패</option>
          </select>
        </div>
        
        <button @click="resetFilters()" 
                class="btn btn-outline">
          필터 초기화
        </button>
      </div>
    </div>
    
    <!-- 로그 테이블 -->
    <div class="log-table-container">
      <div x-show="isLoading" 
           class="loading-indicator"
           role="status" 
           aria-label="로그인 기록 로딩 중">
        <div class="spinner"></div>
        <span>로그인 기록을 불러오는 중...</span>
      </div>
      
      <table x-show="!isLoading" 
             class="log-table table-responsive"
             role="table">
        <thead>
          <tr>
            <th @click="sortBy('timestamp')"
                :class="{ active: sortColumn === 'timestamp' }"
                class="sortable">
              시간 
              <span x-show="sortColumn === 'timestamp'"
                    :class="sortDirection === 'asc' ? 'sort-asc' : 'sort-desc'"
                    aria-hidden="true">⇅</span>
            </th>
            <th>사용자</th>
            <th>이메일</th>
            <th @click="sortBy('status')"
                :class="{ active: sortColumn === 'status' }"
                class="sortable">
              상태
              <span x-show="sortColumn === 'status'"
                    :class="sortDirection === 'asc' ? 'sort-asc' : 'sort-desc'"
                    aria-hidden="true">⇅</span>
            </th>
            <th>IP 주소</th>
            <th>브라우저</th>
          </tr>
        </thead>
        <tbody>
          <template x-for="log in paginatedLogs" :key="log.id">
            <tr :class="{ 'log-failed': log.status === 'failed' }">
              <td x-text="formatDate(log.timestamp)"></td>
              <td x-text="log.user_name"></td>
              <td x-text="log.user_email"></td>
              <td>
                <span :class="log.status === 'success' ? 'badge-success' : 'badge-error'"
                      x-text="log.status === 'success' ? '성공' : '실패'"></span>
              </td>
              <td x-text="log.ip_address"></td>
              <td x-text="log.user_agent" class="truncate"></td>
            </tr>
          </template>
        </tbody>
      </table>
      
      <!-- 빈 상태 -->
      <div x-show="!isLoading && paginatedLogs.length === 0" 
           class="empty-state">
        <p>검색 조건에 맞는 로그인 기록이 없습니다.</p>
      </div>
    </div>
    
    <!-- 페이지네이션 -->
    <div x-show="!isLoading && totalPages > 1" 
         class="pagination" 
         role="navigation" 
         aria-label="로그인 기록 페이지네이션">
      <button @click="setPage(1)" 
              :disabled="currentPage === 1"
              class="pagination-btn"
              aria-label="첫 페이지로">
        ⟪
      </button>
      
      <button @click="setPage(currentPage - 1)" 
              :disabled="currentPage === 1"
              class="pagination-btn"
              aria-label="이전 페이지">
        ⟨
      </button>
      
      <span class="pagination-info">
        <span x-text="currentPage"></span> / <span x-text="totalPages"></span>
      </span>
      
      <button @click="setPage(currentPage + 1)" 
              :disabled="currentPage === totalPages"
              class="pagination-btn"
              aria-label="다음 페이지">
        ⟩
      </button>
      
      <button @click="setPage(totalPages)" 
              :disabled="currentPage === totalPages"
              class="pagination-btn"
              aria-label="마지막 페이지로">
        ⟫
      </button>
      
      <div class="pagination-size">
        <label for="page-size">페이지 크기:</label>
        <select id="page-size"
                x-model="pageSize"
                @change="setLimit($event.target.value)"
                class="pagination-select">
          <option value="10">10</option>
          <option value="25">25</option>
          <option value="50">50</option>
          <option value="100">100</option>
        </select>
      </div>
    </div>
  </div>
</div>

<script>
// 로그인 기록 뷰어 Alpine.js 데이터 함수
function loginLogViewer() {
  return {
    // 로그 데이터
    logs: [],
    filteredLogs: [],
    paginatedLogs: [],
    
    // 로딩 상태
    isLoading: false,
    
    // 필터 상태
    filters: {
      user: '',
      dateFrom: '',
      dateTo: '',
      status: ''
    },
    
    // 정렬 상태
    sortColumn: 'timestamp',
    sortDirection: 'desc',
    
    // 페이지네이션 상태
    currentPage: 1,
    pageSize: 25,
    totalPages: 1,
    
    // 에러 상태
    error: null,
    
    // 디바운스 타이머
    filterTimeout: null,
    
    // 초기화
    async init() {
      await this.loadLogs();
    },
    
    // 로그 데이터 로드
    async loadLogs() {
      this.isLoading = true;
      try {
        const response = await fetch('/api/admin/login-logs', {
          headers: {
            'Authorization': `Bearer ${localStorage.getItem('token')}`,
            'Content-Type': 'application/json'
          }
        });
        
        if (!response.ok) {
          throw new Error('로그인 기록을 불러올 수 없습니다');
        }
        
        this.logs = await response.json();
        this.applyFilters();
      } catch (error) {
        this.error = error.message;
      } finally {
        this.isLoading = false;
      }
    },
    
    // 필터 적용 (디바운스)
    debounceFilter() {
      clearTimeout(this.filterTimeout);
      this.filterTimeout = setTimeout(() => {
        this.applyFilters();
      }, 300);
    },
    
    // 필터 적용
    applyFilters() {
      this.filteredLogs = this.logs.filter(log => {
        // 사용자 필터
        if (this.filters.user && 
            !log.user_name.toLowerCase().includes(this.filters.user.toLowerCase()) &&
            !log.user_email.toLowerCase().includes(this.filters.user.toLowerCase())) {
          return false;
        }
        
        // 날짜 필터
        const logDate = new Date(log.timestamp).toISOString().split('T')[0];
        if (this.filters.dateFrom && logDate < this.filters.dateFrom) {
          return false;
        }
        if (this.filters.dateTo && logDate > this.filters.dateTo) {
          return false;
        }
        
        // 상태 필터
        if (this.filters.status && log.status !== this.filters.status) {
          return false;
        }
        
        return true;
      });
      
      this.applySorting();
      this.updatePagination();
    },
    
    // 정렬 적용
    applySorting() {
      this.filteredLogs.sort((a, b) => {
        let aVal = a[this.sortColumn];
        let bVal = b[this.sortColumn];
        
        if (this.sortColumn === 'timestamp') {
          aVal = new Date(aVal);
          bVal = new Date(bVal);
        }
        
        if (this.sortDirection === 'asc') {
          return aVal < bVal ? -1 : aVal > bVal ? 1 : 0;
        } else {
          return aVal > bVal ? -1 : aVal < bVal ? 1 : 0;
        }
      });
    },
    
    // 페이지네이션 업데이트
    updatePagination() {
      this.totalPages = Math.ceil(this.filteredLogs.length / this.pageSize);
      
      // 현재 페이지가 총 페이지를 초과할 경우 조정
      if (this.currentPage > this.totalPages && this.totalPages > 0) {
        this.currentPage = this.totalPages;
      }
      
      const startIndex = (this.currentPage - 1) * this.pageSize;
      const endIndex = startIndex + this.pageSize;
      this.paginatedLogs = this.filteredLogs.slice(startIndex, endIndex);
    },
    
    // 정렬 기능
    sortBy(column) {
      if (this.sortColumn === column) {
        this.sortDirection = this.sortDirection === 'asc' ? 'desc' : 'asc';
      } else {
        this.sortColumn = column;
        this.sortDirection = 'desc';
      }
      this.applyFilters();
    },
    
    // 페이지 이동
    setPage(page) {
      if (page >= 1 && page <= this.totalPages) {
        this.currentPage = page;
        this.updatePagination();
      }
    },
    
    // 페이지 크기 설정
    setLimit(limit) {
      this.pageSize = parseInt(limit);
      this.currentPage = 1;
      this.updatePagination();
    },
    
    // 필터 초기화
    resetFilters() {
      this.filters = {
        user: '',
        dateFrom: '',
        dateTo: '',
        status: ''
      };
      this.currentPage = 1;
      this.applyFilters();
    },
    
    // 에러 클리어
    clearError() {
      this.error = null;
    },
    
    // 날짜 포맷팅
    formatDate(dateString) {
      return new Date(dateString).toLocaleString('ko-KR', {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit'
      });
    }
  };
}
</script>
```

---

## 🔗 **관련 문서**

- **[05_컴포넌트_설계.md](./05_컴포넌트_설계.md)**: 컴포넌트와 상태 연결
- **[07_API_설계.md](./07_API_설계.md)**: API 호출 및 데이터 관리
- **[12_개발_가이드.md](./12_개발_가이드.md)**: 상태 관리 개발 가이드라인
