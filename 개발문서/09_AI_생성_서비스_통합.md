# 🤖 IEPON AI 생성 서비스 통합 설계 (HTML + Alpine.js + HTMX + Supabase)

> **연결 문서**: [02_데이터베이스_설계.md](./02_데이터베이스_설계.md) | [07_API_설계.md](./07_API_설계.md) | [04_주요_기능_명세.md](./04_주요_기능_명세.md)
> **기술 스택**: HTML5 + Alpine.js + HTMX + Supabase + Supabase Edge Functions

---

## 9.1 통합 AI 생성 서비스 아키텍처

### 9.1.1 핵심 설계 원칙
- **학생 컨텍스트 중심**: 모든 AI 생성에서 학생별 개별화 데이터 자동 반영
- **서비스별 맞춤화**: 각 서비스 특성에 맞는 데이터 매핑 및 프롬프트 최적화
- **일관성 보장**: 통합된 Alpine.js 스토어를 통한 일관된 AI 생성 경험
- **성능 최적화**: Supabase 캐싱 및 Edge Functions를 통한 지능형 데이터 로딩
- **UTF-8 안전성**: 모든 AI 생성 과정에서 한글 및 특수문자 안전성 보장
- **접근성 우선**: WCAG 2.1 AA 준수 및 스크린 리더 지원

### 9.1.2 서비스 분류
```javascript
// Alpine.js 글로벌 상수 정의
const AI_SERVICE_TYPES = {
  CURRICULUM_ASSIGNMENT: 'curriculum_assignment',
  LESSON_PLAN: 'lesson_plan', 
  ASSESSMENT: 'assessment',
  ADMIN_DOCUMENT: 'admin_document',
  COUNSELING_GUIDE: 'counseling_guide'
};

// 서비스별 한글 라벨
const AI_SERVICE_LABELS = {
  [AI_SERVICE_TYPES.CURRICULUM_ASSIGNMENT]: '교육과정 배정',
  [AI_SERVICE_TYPES.LESSON_PLAN]: '교육계획 수립',
  [AI_SERVICE_TYPES.ASSESSMENT]: '교육평가',
  [AI_SERVICE_TYPES.ADMIN_DOCUMENT]: '행정문서',
  [AI_SERVICE_TYPES.COUNSELING_GUIDE]: '상담가이드'
};
```

### 9.1.3 기술 스택별 역할
```html
<!-- HTML5: 시맨틱 구조와 접근성 기반 마크업 -->
<section class="ai-generation-dashboard" role="main" aria-label="AI 생성 서비스 대시보드">
  <header class="section-header">
    <h2 class="visually-hidden">AI 생성 서비스 선택</h2>
  </header>
  
  <!-- Alpine.js: 상태 관리 및 반응형 UI 로직 -->
  <div x-data="aiServiceHub()" x-init="initServices()">
    <!-- HTMX: 서버와의 실시간 통신 및 UI 업데이트 -->
    <div hx-get="/api/ai-generation/status" 
         hx-trigger="every 30s" 
         hx-target="#service-status">
      <!-- 서비스 상태 실시간 업데이트 영역 -->
    </div>
  </div>
</section>
```

```javascript
// Supabase Edge Functions: AI API 호출 및 비즈니스 로직
// Edge Function 예시 구조
const aiGenerationHandler = {
  async handleRequest(request, serviceType, studentContext) {
    // UTF-8 안전성 검증
    const safeContext = validateUTF8Context(studentContext);
    
    // AI API 호출
    const aiResponse = await callOpenAI(request, safeContext);
    
    // 결과 검증 및 저장
    return await saveGenerationResult(aiResponse);
  }
};
```

---

## 9.2 통합 AI 생성 서비스 데이터 구조 (Alpine.js)

### 9.2.1 AI 생성 서비스 데이터 타입 정의

#### 핵심 데이터 구조체
```javascript
/**
 * AI 생성 결과 통합 데이터 구조
 * Alpine.js 스토어와 HTMX 응답에서 사용
 */
const createAIGenerationResult = () => ({
  id: '',
  serviceType: '',
  studentId: '',
  generatedContent: null,
  metadata: createAIGenerationMetadata(),
  contextUsage: createContextUsageInfo(),
  qualityScore: 0,
  confidenceLevel: 0,
  generatedAt: '',
  validatedAt: null,
  errors: [],
  warnings: [],
  
  // UTF-8 안전성 검증 메서드
  validateUTF8() {
    return validateUTF8Text(this.generatedContent);
  },
  
  // 접근성 정보 생성
  getAccessibilityInfo() {
    return {
      ariaLabel: `${AI_SERVICE_LABELS[this.serviceType]} 생성 결과`,
      role: 'region',
      'aria-live': this.errors.length > 0 ? 'assertive' : 'polite'
    };
  }
});

/**
 * AI 생성 메타데이터 구조
 */
const createAIGenerationMetadata = () => ({
  model: '',
  temperature: 0.7,
  maxTokens: 2000,
  promptTokens: 0,
  completionTokens: 0,
  totalTokens: 0,
  processingTime: 0,
  retryCount: 0,
  version: '1.0.0',
  
  // 성능 메트릭 계산
  calculateEfficiency() {
    if (this.totalTokens === 0) return 0;
    return Math.round((this.completionTokens / this.totalTokens) * 100);
  }
});

/**
 * 컨텍스트 사용 정보 구조
 */
const createContextUsageInfo = () => ({
  dataSourcesUsed: [],
  contextCompleteness: 0,
  individualizedElements: [],
  adaptationsApplied: [],
  supportNeedsAddressed: [],
  
  // 개별화 수준 계산
  getIndividualizationLevel() {
    const totalElements = this.individualizedElements.length + 
                         this.adaptationsApplied.length + 
                         this.supportNeedsAddressed.length;
    if (totalElements >= 5) return 'high';
    if (totalElements >= 3) return 'medium';
    return 'low';
  }
});

/**
 * 서비스별 매핑 데이터 기본 구조
 */
const createServiceSpecificMappedData = (serviceType) => ({
  serviceType,
  mappedAt: new Date().toISOString(),
  dataQuality: 0,
  
  // 데이터 품질 검증
  validateQuality() {
    // 기본 품질 검증 로직
    this.dataQuality = Math.random() * 100; // 실제로는 복잡한 검증 로직
    return this.dataQuality > 70;
  }
});

/**
 * 사용자 선호도 구조
 */
const createUserPreferences = () => ({
  language: 'ko',
  tone: 'professional',
  detailLevel: 'moderate',
  includeExamples: true,
  focusAreas: [],
  avoidTerms: [],
  customInstructions: '',
  
  // 선호도 검증 및 적용
  applyToRequest(request) {
    return {
      ...request,
      preferences: { ...this },
      processedAt: new Date().toISOString()
    };
  }
});

/**
 * AI 생성 요청 기본 구조
 */
const createBaseAIGenerationRequest = () => ({
  studentId: '',
  serviceType: '',
  requestId: '',
  priority: 'normal',
  deadline: null,
  additionalContext: {},
  
  // 요청 검증
  validate() {
    const errors = [];
    if (!this.studentId) errors.push('학생 ID가 필요합니다');
    if (!this.serviceType) errors.push('서비스 타입이 필요합니다');
    if (!this.requestId) errors.push('요청 ID가 필요합니다');
    return { isValid: errors.length === 0, errors };
  },
  
  // UTF-8 안전성 검사
  ensureUTF8Safety() {
    Object.keys(this.additionalContext).forEach(key => {
      if (typeof this.additionalContext[key] === 'string') {
        this.additionalContext[key] = validateAndSanitizeUTF8(this.additionalContext[key]);
      }
    });
  }
});

/**
 * AI 생성 에러 처리 유틸리티
 * JavaScript 기반 에러 처리 및 사용자 친화적 메시지 제공
 */
class AIGenerationError extends Error {
  constructor(
    message,
    serviceType = '',
    code = 'GENERATION_FAILED',
    context = null,
    retryable = true
  ) {
    super(message);
    this.name = 'AIGenerationError';
    this.code = code;
    this.serviceType = serviceType;
    this.context = context;
    this.timestamp = new Date().toISOString();
    this.retryable = retryable;

    // 스택 트레이스 캡처 (브라우저 호환성 고려)
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, AIGenerationError);
    }
  }

  /**
   * 사용자 친화적인 에러 메시지 생성
   * 접근성을 고려한 명확한 한글 메시지 제공
   */
  getUserFriendlyMessage() {
    switch (this.code) {
      case 'CONTEXT_BUILD_FAILED':
        return '학생 정보를 불러오는 중 오류가 발생했습니다.';
      case 'AI_API_ERROR':
        return 'AI 서비스 연결에 문제가 발생했습니다.';
      case 'VALIDATION_FAILED':
        return '생성된 내용의 검증에 실패했습니다.';
      case 'QUOTA_EXCEEDED':
        return 'AI 생성 할당량을 초과했습니다.';
      case 'UTF8_ENCODING_ERROR':
        return '텍스트 인코딩 처리 중 오류가 발생했습니다.';
      case 'NETWORK_ERROR':
        return '네트워크 연결에 문제가 발생했습니다.';
      case 'TIMEOUT_ERROR':
        return 'AI 생성 시간이 초과되었습니다.';
      default:
        return 'AI 생성 중 오류가 발생했습니다.';
    }
  }

  /**
   * 접근성을 위한 ARIA 정보 생성
   */
  getAccessibilityInfo() {
    return {
      role: 'alert',
      'aria-live': 'assertive',
      'aria-label': `오류 발생: ${this.getUserFriendlyMessage()}`
    };
  }

  /**
   * 에러 정보를 Alpine.js 스토어 형태로 변환
   */
  toAlpineStore() {
    return {
      hasError: true,
      error: {
        code: this.code,
        message: this.getUserFriendlyMessage(),
        timestamp: this.timestamp,
        retryable: this.retryable,
        serviceType: this.serviceType,
        accessibility: this.getAccessibilityInfo()
      }
    };
  }
}

/**
 * 에러 처리 유틸리티 함수들
 */
const errorUtils = {
  /**
   * 에러를 사용자 친화적인 형태로 처리
   */
  handleError(error, serviceType) {
    console.error('AI Generation Error:', error);
    
    if (error instanceof AIGenerationError) {
      return error.toAlpineStore();
    }
    
    // 일반 에러를 AI 생성 에러로 변환
    const aiError = new AIGenerationError(
      error.message || '알 수 없는 오류가 발생했습니다.',
      serviceType,
      'UNKNOWN_ERROR',
      { originalError: error },
      true
    );
    
    return aiError.toAlpineStore();
  },

  /**
   * UTF-8 안전성 검증 에러 처리
   */
  handleUTF8Error(text, context) {
    return new AIGenerationError(
      'UTF-8 인코딩 처리 중 오류가 발생했습니다.',
      context.serviceType || '',
      'UTF8_ENCODING_ERROR',
      { text, context },
      false
    );
  },

  /**
   * 네트워크 에러 처리
   */
  handleNetworkError(response, serviceType) {
    const code = response.status >= 500 ? 'SERVER_ERROR' : 'NETWORK_ERROR';
    return new AIGenerationError(
      `네트워크 오류 (${response.status}): ${response.statusText}`,
      serviceType,
      code,
      { status: response.status, statusText: response.statusText },
      response.status < 500 // 4xx 에러는 재시도 불가, 5xx 에러는 재시도 가능
    );
  }
};
```

### 9.2.2 AI 생성 서비스 Alpine.js 컴포넌트

#### 클라이언트 측 AI 생성 관리자 (Alpine.js)
```javascript
/**
 * AI 생성 서비스 Alpine.js 컴포넌트
 * 모든 AI 생성 서비스의 공통 기능과 워크플로우를 관리
 */
function aiGenerationService() {
  return {
    // 상태 관리
    serviceType: '',
    isLoading: false,
    error: null,
    result: null,
    progress: 0,
    maxRetries: 3,
    currentRetry: 0,
    requestTimeout: 30000, // 30초
    
    // 설정
    config: {
      apiBaseUrl: '/api/ai-generation',
      rateLimitWindow: 60000, // 1분
      maxRequestsPerWindow: 100
    },
    
    // 초기화
    init() {
      this.setupEventListeners();
      this.validateEnvironment();
      console.log(`AI Generation Service 초기화됨 (서비스: ${this.serviceType})`);
    },
    
    /**
     * 환경 검증 (UTF-8 인코딩, Supabase 연결 등)
     */
    validateEnvironment() {
      // UTF-8 인코딩 지원 확인
      if (!window.TextEncoder || !window.TextDecoder) {
        this.error = errorUtils.handleUTF8Error('브라우저 UTF-8 지원 없음', { serviceType: this.serviceType });
        return false;
      }
      
      // Supabase 클라이언트 확인
      if (!window.supabase) {
        this.error = new AIGenerationError(
          'Supabase 클라이언트가 초기화되지 않았습니다.',
          this.serviceType,
          'SUPABASE_NOT_INITIALIZED',
          null,
          false
        ).toAlpineStore();
        return false;
      }
      
      return true;
    },
    
    /**
     * 학생 컨텍스트 기반 AI 생성 메인 메서드
     * HTMX와 Supabase Edge Functions를 활용한 구현
     */
    async generateWithContext(studentId, requestData, teacherPreferences = null) {
      if (!this.validateEnvironment()) {
        return this.error;
      }
      
      this.isLoading = true;
      this.error = null;
      this.currentRetry = 0;
      this.progress = 0;
      
      try {
        // 1. 요청 검증 및 UTF-8 안전성 확인
        const validation = this.validateRequest(studentId, requestData);
        if (!validation.isValid) {
          throw new AIGenerationError(
            validation.errors.join(', '),
            this.serviceType,
            'VALIDATION_FAILED',
            { errors: validation.errors },
            false
          );
        }
        
        // 2. 속도 제한 확인
        await this.checkRateLimit(studentId);
        this.progress = 10;
        
        // 3. 재시도 로직으로 AI 생성 실행
        const result = await this.executeWithRetry(
          () => this.performAIGeneration(studentId, requestData, teacherPreferences)
        );
        
        this.result = result;
        this.progress = 100;
        
        return result;
        
      } catch (error) {
        this.error = errorUtils.handleError(error, this.serviceType);
        return this.error;
      } finally {
        this.isLoading = false;
      }
    },
    
    /**
     * 재시도 로직이 포함된 실행기
     */
    async executeWithRetry(operationFn) {
      let lastError = null;
      
      for (let retry = 0; retry < this.maxRetries; retry++) {
        this.currentRetry = retry;
        
        try {
          return await operationFn();
          
        } catch (error) {
          lastError = error;
          
          // 재시도 불가능한 에러인 경우 즉시 중단
          if (error instanceof AIGenerationError && !error.retryable) {
            throw error;
          }
          
          // 마지막 재시도인 경우 에러 발생
          if (retry >= this.maxRetries - 1) {
            throw new AIGenerationError(
              `AI 생성 실패 (${retry + 1}회 재시도): ${error.message}`,
              this.serviceType,
              'MAX_RETRIES_EXCEEDED',
              { originalError: error, retryCount: retry + 1 }
            );
          }
          
          // 지수 백오프로 재시도 대기
          const delay = Math.min(1000 * Math.pow(2, retry), 5000); // 최대 5초
          await this.sleep(delay);
          
          console.warn(`AI 생성 재시도 ${retry + 1}/${this.maxRetries}:`, error.message);
        }
      }
      
      throw lastError || new AIGenerationError(
        '예상치 못한 오류로 AI 생성에 실패했습니다.',
        this.serviceType,
        'UNEXPECTED_ERROR'
      );
    },
    
    /**
     * 실제 AI 생성 수행 (Supabase Edge Functions 활용)
     */
    async performAIGeneration(studentId, requestData, teacherPreferences) {
      const startTime = Date.now();
      
      // 1. 학생 컨텍스트 구축 (Supabase에서 데이터 조회)
      const studentContext = await this.buildStudentContext(studentId);
      this.progress = 30;
      
      // 2. 서비스별 데이터 매핑
      const mappedData = await this.mapDataForService(studentContext, requestData);
      this.progress = 40;
      
      // 3. Edge Function을 통한 AI 생성 요청
      const aiResult = await this.callSupabaseEdgeFunction({
        studentContext,
        mappedData,
        requestData,
        teacherPreferences
      });
      this.progress = 70;
      
      // 4. 결과 후처리 및 검증
      const validatedResult = await this.validateAndEnhanceResult(
        aiResult,
        studentContext,
        requestData
      );
      this.progress = 85;
      
      // 5. 사용 이력 저장
      await this.saveGenerationHistory({
        studentId,
        result: validatedResult,
        processingTime: Date.now() - startTime
      });
      this.progress = 95;
      
      return validatedResult;
    },

    
    /**
     * 요청 검증 및 UTF-8 안전성 확인
     */
    validateRequest(studentId, requestData) {
      const errors = [];
      
      // 기본 필드 검증
      if (!studentId || typeof studentId !== 'string') {
        errors.push('유효하지 않은 학생 ID입니다.');
      }
      
      if (!requestData) {
        errors.push('요청 데이터가 필요합니다.');
        return { isValid: false, errors };
      }
      
      // 요청 데이터 검증 (내장 validate 메서드 사용)
      const requestValidation = requestData.validate ? requestData.validate() : { isValid: true, errors: [] };
      if (!requestValidation.isValid) {
        errors.push(...requestValidation.errors);
      }
      
      // UTF-8 안전성 검증
      try {
        const textFields = [studentId, requestData.requestId, requestData.serviceType];
        textFields.forEach(field => {
          if (field && !this.isValidUTF8(field)) {
            errors.push(`UTF-8 인코딩이 올바르지 않은 필드가 있습니다: ${field}`);
          }
        });
        
        // 추가 컨텍스트의 UTF-8 검증
        if (requestData.additionalContext) {
          Object.values(requestData.additionalContext).forEach(value => {
            if (typeof value === 'string' && !this.isValidUTF8(value)) {
              errors.push('추가 컨텍스트에 UTF-8 인코딩 오류가 있습니다.');
            }
          });
        }
      } catch (error) {
        errors.push('UTF-8 인코딩 검증 중 오류가 발생했습니다.');
      }
      
      return {
        isValid: errors.length === 0,
        errors
      };
    },
    
    /**
     * UTF-8 문자열 유효성 검사
     */
    isValidUTF8(str) {
      try {
        const encoded = new TextEncoder().encode(str);
        const decoded = new TextDecoder('utf-8', { fatal: true }).decode(encoded);
        return decoded === str;
      } catch (error) {
        return false;
      }
    },
    
    /**
     * 속도 제한 확인 (클라이언트 측 기본 체크)
     */
    async checkRateLimit(studentId) {
      const key = `rate_limit_${studentId}_${this.serviceType}`;
      const now = Date.now();
      const windowStart = now - this.config.rateLimitWindow;
      
      // 로컬 스토리지에서 최근 요청 기록 확인
      const requests = JSON.parse(localStorage.getItem(key) || '[]');
      const recentRequests = requests.filter(timestamp => timestamp > windowStart);
      
      if (recentRequests.length >= this.config.maxRequestsPerWindow) {
        throw new AIGenerationError(
          `속도 제한 초과: ${this.config.rateLimitWindow / 1000}초당 최대 ${this.config.maxRequestsPerWindow}회 요청 가능`,
          this.serviceType,
          'RATE_LIMIT_EXCEEDED',
          { requestCount: recentRequests.length, windowStart, now },
          true // 시간이 지나면 재시도 가능
        );
      }
      
      // 현재 요청 기록 추가
      recentRequests.push(now);
      localStorage.setItem(key, JSON.stringify(recentRequests));
    },
    
    /**
     * 학생 컨텍스트 구축 (Supabase에서 데이터 조회)
     */
    async buildStudentContext(studentId) {
      try {
        const { data, error } = await window.supabase
          .rpc('get_student_context_for_ai', {
            student_id: studentId,
            service_type: this.serviceType
          });
        
        if (error) {
          throw new AIGenerationError(
            `학생 컨텍스트 구축 실패: ${error.message}`,
            this.serviceType,
            'CONTEXT_BUILD_FAILED',
            { studentId, supabaseError: error },
            true
          );
        }
        
        // UTF-8 안전성 검증
        if (data && !this.validateContextUTF8(data)) {
          throw errorUtils.handleUTF8Error('학생 컨텍스트 데이터', {
            serviceType: this.serviceType,
            studentId
          });
        }
        
        return data;
      } catch (error) {
        if (error instanceof AIGenerationError) {
          throw error;
        }
        throw new AIGenerationError(
          `학생 컨텍스트 구축 중 오류: ${error.message}`,
          this.serviceType,
          'CONTEXT_BUILD_FAILED',
          { studentId, originalError: error }
        );
      }
    },
    
      context,
      requestData
    ) {
      // 기본 데이터 매핑 (각 서비스별로 오버라이드 가능)
      const mappedData = createServiceSpecificMappedData(this.serviceType);
      
      // 공통 매핑 로직
      mappedData.studentProfile = {
        id: context.profile?.id,
        name: context.profile?.name,
        grade: context.profile?.grade,
        disabilityType: context.profile?.disabilityType
      };
      
      mappedData.currentLevels = context.currentLevels || {};
      mappedData.learningHistory = context.recentActivities || [];
      mappedData.supportNeeds = context.supportNeeds || [];
      
      // 데이터 품질 검증
      mappedData.validateQuality();
      
      return mappedData;
    },
    
    /**
     * 컨텍스트 사용 정보 검증
     */
    validateContextUTF8(context) {
      try {
        const jsonStr = JSON.stringify(context);
        return this.isValidUTF8(jsonStr);
      } catch (error) {
        return false;
      }
    },
    
    /**
     * Supabase Edge Function 호출
     */
    async callSupabaseEdgeFunction(payload) {
      try {
        const { data, error } = await window.supabase.functions.invoke(
          'ai-generation-service',
          {
            body: {
              ...payload,
              serviceType: this.serviceType,
              timestamp: new Date().toISOString()
            }
          }
        );
        
        if (error) {
          throw new AIGenerationError(
            `AI 생성 서비스 호출 실패: ${error.message}`,
            this.serviceType,
            'AI_API_ERROR',
            { supabaseError: error },
            true
          );
        }
        
        return data;
      } catch (error) {
        if (error instanceof AIGenerationError) {
          throw error;
        }
        throw errorUtils.handleNetworkError(
          { status: 500, statusText: error.message },
          this.serviceType
        );
      }
    },
    
    /**
     * AI 결과 검증 및 향상
     */
    async validateAndEnhanceResult(
      aiResult,
      context,
      requestData
    ) {
      const result = createAIGenerationResult();
      
      // 기본 정보 설정
      result.id = `ai_gen_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      result.serviceType = this.serviceType;
      result.studentId = context.profile?.id;
      result.generatedContent = aiResult.content;
      result.generatedAt = new Date().toISOString();
      
      // 메타데이터 설정
      result.metadata = {
        ...createAIGenerationMetadata(),
        ...aiResult.metadata,
        requestId: requestData.requestId,
        serviceType: this.serviceType
      };
      
      // UTF-8 안전성 검증
      if (!result.validateUTF8()) {
        throw errorUtils.handleUTF8Error(
          result.generatedContent,
          { serviceType: this.serviceType, resultId: result.id }
        );
      }
      
      // 컨텍스트 사용 정보 설정
      result.contextUsage = createContextUsageInfo();
      result.contextUsage.dataSourcesUsed = ['student_profile', 'learning_history', 'support_needs'];
      result.contextUsage.contextCompleteness = this.calculateContextCompleteness(context);
      
      // 품질 점수 계산
      result.qualityScore = this.calculateQualityScore(result, context);
      result.confidenceLevel = this.calculateConfidenceLevel(result);
      
      result.validatedAt = new Date().toISOString();
      
      return result;
    },
    
    /**
     * 컨텍스트 완성도 계산
     */
    calculateContextCompleteness(context) {
      const requiredFields = ['profile', 'currentLevels', 'supportNeeds'];
      const availableFields = requiredFields.filter(field => context[field] && Object.keys(context[field]).length > 0);
      return Math.round((availableFields.length / requiredFields.length) * 100);
    },
    
    /**
     * 품질 점수 계산
     */
    calculateQualityScore(result, context) {
      let score = 0;
      
      // 기본 점수 (50점)
      score += 50;
      
      // 컨텍스트 완성도 반영 (30점)
      score += (result.contextUsage.contextCompleteness / 100) * 30;
      
      // 콘텐츠 길이 적절성 (10점)
      const contentLength = result.generatedContent ? result.generatedContent.length : 0;
      if (contentLength > 100 && contentLength < 5000) {
        score += 10;
      }
      
      // UTF-8 안전성 (10점)
      if (result.validateUTF8()) {
        score += 10;
      }
      
      return Math.min(Math.round(score), 100);
    },
    
    /**
     * 신뢰도 계산
     */
    calculateConfidenceLevel(result) {
      // 기본 신뢰도는 품질 점수 기반
      let confidence = result.qualityScore;
      
      // 메타데이터가 있으면 추가 점수
      if (result.metadata && result.metadata.totalTokens > 0) {
        confidence += 5;
      }
      
      // 컨텍스트 사용도가 높으면 추가 점수
      if (result.contextUsage && result.contextUsage.contextCompleteness > 80) {
        confidence += 10;
      }
      
      return Math.min(Math.round(confidence), 100);
    },
    
    /**
     * 생성 이력 저장
     */
    async saveGenerationHistory(historyData) {
      try {
        const { data: { user } } = await window.supabase.auth.getUser();
        if (!user) return;
        
        const { error } = await window.supabase
          .from('ai_generation_history')
          .insert({
            student_id: historyData.studentId,
            user_id: user.id,
            service_type: this.serviceType,
            result_id: historyData.result.id,
            processing_time: historyData.processingTime,
            quality_score: historyData.result.qualityScore,
            confidence_level: historyData.result.confidenceLevel,
            created_at: new Date().toISOString()
          });
        
        if (error) {
          console.warn('생성 이력 저장 실패:', error);
          // 비치명적 오류이므로 예외를 던지지 않음
        }
      } catch (error) {
        console.warn('생성 이력 저장 중 오류:', error);
      }
    },

    
    /**
     * 유틸리티: sleep 함수
     */
    sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    },
    
    /**
     * 이벤트 리스너 설정
     */
    setupEventListeners() {
      // 컴포넌트 정리 시 리소스 해제
      this.$nextTick(() => {
        if (this.$el) {
          this.$el.addEventListener('beforeunload', () => {
            this.cleanup();
          });
        }
      });
    },
    
    /**
     * 리소스 정리
     */
    cleanup() {
      this.isLoading = false;
      this.error = null;
      this.result = null;
      this.progress = 0;
    }
  };
}

/**
 * AI 생성 서비스 팩토리 함수
 * 특정 서비스 타입에 맞는 컴포넌트 생성
 */
function createAIService(serviceType) {
  const baseService = aiGenerationService();
  baseService.serviceType = serviceType;
  
  // 서비스별 특화 로직 추가
  switch (serviceType) {
    case AI_SERVICE_TYPES.CURRICULUM_ASSIGNMENT:
      return { ...baseService, ...curriculumAssignmentExtensions() };
    case AI_SERVICE_TYPES.LESSON_PLAN:
      return { ...baseService, ...lessonPlanExtensions() };
    case AI_SERVICE_TYPES.ASSESSMENT:
      return { ...baseService, ...assessmentExtensions() };
    case AI_SERVICE_TYPES.ADMIN_DOCUMENT:
      return { ...baseService, ...adminDocumentExtensions() };
    case AI_SERVICE_TYPES.COUNSELING_GUIDE:
      return { ...baseService, ...counselingGuideExtensions() };
    default:
      return baseService;
  }
}

/**
 * 서비스별 확장 함수들 (각각 별도로 구현)
 */
function curriculumAssignmentExtensions() {
  return {
    // 교육과정 배정 특화 로직
    async mapDataForService(context, requestData) {
      const mappedData = createServiceSpecificMappedData(AI_SERVICE_TYPES.CURRICULUM_ASSIGNMENT);
      mappedData.currentLevel = context.currentLevels?.overall || 'beginner';
      mappedData.preferredSubjects = context.preferences?.subjects || [];
      mappedData.learningPace = context.analytics?.averagePace || 'normal';
      return mappedData;
    }
  };
}

function lessonPlanExtensions() {
  return {
    // 교육계획 수립 특화 로직
    async mapDataForService(context, requestData) {
      const mappedData = createServiceSpecificMappedData(AI_SERVICE_TYPES.LESSON_PLAN);
      mappedData.targetSkills = context.goals?.targetSkills || [];
      mappedData.teachingMethods = context.preferences?.teachingMethods || [];
      mappedData.sessionDuration = context.preferences?.sessionDuration || 30;
      return mappedData;
    }
  };
}

function assessmentExtensions() {
  return {
    // 교육평가 특화 로직
    async mapDataForService(context, requestData) {
      const mappedData = createServiceSpecificMappedData(AI_SERVICE_TYPES.ASSESSMENT);
      mappedData.assessmentHistory = context.assessments?.recent || [];
      mappedData.strengthAreas = context.analytics?.strengths || [];
      mappedData.improvementAreas = context.analytics?.improvements || [];
      return mappedData;
    }
  };
}

function adminDocumentExtensions() {
  return {
    // 행정문서 특화 로직
    async mapDataForService(context, requestData) {
      const mappedData = createServiceSpecificMappedData(AI_SERVICE_TYPES.ADMIN_DOCUMENT);
      mappedData.documentType = requestData.additionalContext?.documentType || 'report';
      mappedData.targetAudience = requestData.additionalContext?.audience || 'parents';
      mappedData.formalityLevel = requestData.additionalContext?.formality || 'professional';
      return mappedData;
    }
  };
}

function counselingGuideExtensions() {
  return {
    // 상담가이드 특화 로직
    async mapDataForService(context, requestData) {
      const mappedData = createServiceSpecificMappedData(AI_SERVICE_TYPES.COUNSELING_GUIDE);
      mappedData.behaviorPatterns = context.observations?.behaviors || [];
      mappedData.emotionalState = context.wellbeing?.currentState || 'stable';
      mappedData.socialInteractions = context.social?.interactions || [];
      return mappedData;
    }
  };
}
  
```

### 9.2.3 유틸리티 함수들 (Alpine.js/JavaScript 기반)

```javascript
/**
 * AI 생성 서비스 유틸리티 함앨들
 * UTF-8 안전성, 접근성, 성능 최적화 고려
 */
const aiServiceUtils = {
  /**
   * Supabase를 통한 컨텍스트 사용 이력 저장
   */
  async saveContextUsage(studentId, context, mappedData, result, serviceType) {
    try {
      const { data: { user } } = await window.supabase.auth.getUser();
      if (!user) return;
      
      const contextUsage = {
        student_id: studentId,
        user_id: user.id,
        service_type: serviceType,
        generation_id: result.id,
        context_snapshot: {
          profile: {
            id: context.profile?.id,
            name: context.profile?.name,
            grade: context.profile?.grade,
            disabilityType: context.profile?.disabilityType,
            buildTimestamp: context.buildTimestamp
          },
          dataCompleteness: context.dataCompleteness,
          individualizedElements: result.contextUsage?.individualizedElements || []
        },
        mapped_data: {
          serviceType: mappedData.serviceType,
          dataQuality: mappedData.dataQuality,
          mappedAt: mappedData.mappedAt
        },
        context_influence_score: this.calculateContextInfluenceScore(context, result),
        data_sources: result.contextUsage?.dataSourcesUsed || []
      };
      
      const { error } = await window.supabase
        .from('ai_generation_contexts')
        .insert(contextUsage);
      
      if (error) {
        console.warn('컨텍스트 사용 이력 저장 실패:', error);
        // 비치명적 오류이므로 예외를 던지지 않음
      }
      
    } catch (error) {
      console.warn('컨텍스트 사용 이력 저장 중 오류:', error);
    }
  },
  
  
  /**
   * Supabase Edge Functions를 통한 성능 메트릭 수집
   */
  async collectPerformanceMetrics(result, totalTime, retryCount, serviceType) {
    try {
      const metrics = {
        service_type: serviceType,
        student_id: result.studentId,
        generation_id: result.id,
        total_processing_time: totalTime,
        ai_processing_time: result.metadata?.processingTime || 0,
        retry_count: retryCount,
        quality_score: result.qualityScore,
        confidence_level: result.confidenceLevel,
        token_usage: {
          prompt_tokens: result.metadata?.promptTokens || 0,
          completion_tokens: result.metadata?.completionTokens || 0,
          total_tokens: result.metadata?.totalTokens || 0
        },
        context_completeness: result.contextUsage?.contextCompleteness || 0,
        individualized_elements_count: result.contextUsage?.individualizedElements?.length || 0,
        timestamp: new Date().toISOString()
      };
      
      // Supabase Edge Function을 비동기로 호출 (성능에 영향 없도록)
      window.supabase.functions.invoke('collect-ai-metrics', {
        body: metrics
      }).catch(error => {
        console.warn('메트릭 수집 실패:', error);
      });
      
    } catch (error) {
      console.warn('성능 메트릭 수집 오류:', error);
    }
  },
  
  
  /**
   * 지수 백오프 기반 재시도 대기
   */
  async waitForRetry(retryCount) {
    const baseDelay = 1000; // 1초
    const maxDelay = 10000; // 10초
    const delay = Math.min(baseDelay * Math.pow(2, retryCount - 1), maxDelay);
    
    return new Promise(resolve => setTimeout(resolve, delay));
  },
  
  
  /**
   * 요청 우선순위에 따른 최적 AI 모델 선택
   */
  getOptimalModel(requestData) {
    switch (requestData.priority) {
      case 'urgent':
      case 'high':
        return 'gpt-4-turbo';
      case 'normal':
        return 'gpt-4';
      case 'low':
        return 'gpt-3.5-turbo';
      default:
        return 'gpt-4';
    }
  },
  
  
  /**
   * 서비스 타입별 최적 AI 온도 설정
   */
  getOptimalTemperature(serviceType) {
    switch (serviceType) {
      case AI_SERVICE_TYPES.CURRICULUM_ASSIGNMENT:
        return 0.3; // 높은 정확성 필요
      case AI_SERVICE_TYPES.LESSON_PLAN:
        return 0.7; // 창의성과 정확성 균형
      case AI_SERVICE_TYPES.ASSESSMENT:
        return 0.2; // 매우 높은 정확성 필요
      case AI_SERVICE_TYPES.ADMIN_DOCUMENT:
        return 0.1; // 최대 정확성 필요
      case AI_SERVICE_TYPES.COUNSELING_GUIDE:
        return 0.8; // 공감과 창의성 필요
      default:
        return 0.7;
    }
  },
  
  
  /**
   * 서비스 타입별 최적 최대 토큰 설정
   */
  getOptimalMaxTokens(serviceType) {
    switch (serviceType) {
      case AI_SERVICE_TYPES.CURRICULUM_ASSIGNMENT:
        return 1000;
      case AI_SERVICE_TYPES.LESSON_PLAN:
        return 2000;
      case AI_SERVICE_TYPES.ASSESSMENT:
        return 1500;
      case AI_SERVICE_TYPES.ADMIN_DOCUMENT:
        return 3000;
      case AI_SERVICE_TYPES.COUNSELING_GUIDE:
        return 2500;
      default:
        return 2000;
    }
  },
  
  
  /**
   * HTTP 상태 코드를 AI 생성 에러 코드로 매핑
   */
  mapHttpStatusToErrorCode(status) {
    switch (status) {
      case 400:
        return 'BAD_REQUEST';
      case 401:
        return 'UNAUTHORIZED';
      case 403:
        return 'FORBIDDEN';
      case 404:
        return 'NOT_FOUND';
      case 429:
        return 'RATE_LIMITED';
      case 500:
        return 'INTERNAL_SERVER_ERROR';
      case 502:
        return 'BAD_GATEWAY';
      case 503:
        return 'SERVICE_UNAVAILABLE';
      case 504:
        return 'GATEWAY_TIMEOUT';
      default:
        return 'HTTP_ERROR';
    }
  }
  
  /**
   * 매핑 데이터에서 핵심 매핑 정보 추출
   */
  extractKeyMappings(mappedData) {
    const keyMappings = {};
    
    // 공통 필드 추출
    Object.keys(mappedData).forEach(key => {
      if (key !== 'serviceType' && key !== 'mappedAt' && key !== 'dataQuality') {
        keyMappings[key] = typeof mappedData[key] === 'object' 
          ? Object.keys(mappedData[key]).length 
          : mappedData[key];
      }
    });
    
    return keyMappings;
  }
  
  /**
   * 컨텍스트 영향도 점수 계산
   */
  calculateContextInfluenceScore(context, result) {
    let score = 0;
    
    // 데이터 완전성 기반 점수 (40%)
    score += (context.dataCompleteness.overall / 100) * 0.4;
    
    // 개별화 요소 반영 점수 (30%)
    const individualizedCount = result.contextUsage.individualizedElements.length;
    score += Math.min(individualizedCount / 10, 1) * 0.3;
    
    // 지원 요구사항 반영 점수 (20%)
    const supportNeedsCount = result.contextUsage.supportNeedsAddressed.length;
    score += Math.min(supportNeedsCount / 5, 1) * 0.2;
    
    // 적응 전략 적용 점수 (10%)
    const adaptationsCount = result.contextUsage.adaptationsApplied.length;
    score += Math.min(adaptationsCount / 3, 1) * 0.1;
    
    return Math.round(score * 100) / 100; // 소수점 둘째 자리까지
  }
  
  /**
   * 리소스 정리 (Alpine.js 컴포넌트 cleanup)
   */
  destroy() {
    if (this.studentContextBuilder) {
      this.studentContextBuilder.destroy();
    }
    
    // Alpine.js 이벤트 리스너 정리
    document.removeEventListener('alpine:cleanup', this.cleanup);
  }
}

/**
 * 속도 제한 클래스 (Alpine.js/JavaScript 버전)
 * 각 사용자의 API 요청 빈도를 제한하여 서버 과부하 방지
 */
class RateLimiter {
  constructor(options = { maxRequests: 10, windowMs: 60000 }) {
    this.requests = new Map(); // 사용자별 요청 히스토리
    this.maxRequests = options.maxRequests; // 최대 요청 수
    this.windowMs = options.windowMs; // 시간 윈도우 (ms)
    
    // 정리 작업 시작 (매 윈도우마다 만료된 요청 삭제)
    this.cleanupInterval = setInterval(() => this.cleanup(), this.windowMs);
  }
  
  /**
   * 속도 제한 확인 (비동기)
   * @param {string} identifier - 사용자 식별자 (예: 사용자 ID 또는 IP)
   * @throws {AIGenerationError} 속도 제한 초과 시 에러 발생
   */
  async checkLimit(identifier) {
    // UTF-8 안전성 검증
    if (!this.validateUTF8String(identifier)) {
      throw new Error('사용자 식별자 인코딩 오류');
    }
    
    const now = Date.now();
    const userRequests = this.requests.get(identifier) || [];
    
    // 윈도우 내 요청만 필터링 (최근 요청들만 유지)
    const recentRequests = userRequests.filter(
      timestamp => now - timestamp < this.windowMs
    );
    
    // 속도 제한 초과 확인
    if (recentRequests.length >= this.maxRequests) {
      const errorMessage = `속도 제한 초과: ${this.maxRequests}개 요청/${Math.round(this.windowMs/1000)}초 내에서`;
      
      throw new AIGenerationError(
        errorMessage,
        'CURRICULUM_ASSIGNMENT', // 기본 서비스 타입
        'RATE_LIMITED',
        { 
          identifier: identifier.substring(0, 8) + '***', // 개인정보 보호
          requestCount: recentRequests.length,
          windowMs: this.windowMs,
          maxRequests: this.maxRequests
        },
        false // 재시도 불가
      );
    }
    
    // 새 요청 추가
    recentRequests.push(now);
    this.requests.set(identifier, recentRequests);
    
    // 접근성: 스크린 리더용 상태 알림
    this.announceRateStatus(identifier, recentRequests.length);
  }
  
  /**
   * 만료된 요청 정리 (내부 메서드)
   */
  cleanup() {
    const now = Date.now();
    const initialSize = this.requests.size;
    
    // 모든 사용자의 요청 히스토리 검사
    for (const [identifier, requests] of this.requests.entries()) {
      const recentRequests = requests.filter(
        timestamp => now - timestamp < this.windowMs
      );
      
      // 최근 요청이 없으면 사용자 삭제, 있으면 업데이트
      if (recentRequests.length === 0) {
        this.requests.delete(identifier);
      } else {
        this.requests.set(identifier, recentRequests);
      }
    }
    
    // 디버깅용 로그 (개발 환경에서만)
    if (process.env.NODE_ENV === 'development') {
      const finalSize = this.requests.size;
      console.log(`RateLimiter cleanup: ${initialSize} → ${finalSize} users`);
    }
  }
  
  /**
   * UTF-8 문자열 검증 유틸리티
   * @param {string} str - 검증할 문자열
   * @returns {boolean} 유효한 UTF-8 문자열 여부
   */
  validateUTF8String(str) {
    try {
      const encoded = new TextEncoder().encode(str);
      const decoded = new TextDecoder('utf-8', { fatal: true }).decode(encoded);
      return decoded === str;
    } catch (error) {
      console.error('UTF-8 인코딩 검증 실패:', error);
      return false;
    }
  }
  
  /**
   * 접근성: 스크린 리더를 위한 속도 제한 상태 알림
   * @param {string} identifier - 사용자 식별자
   * @param {number} currentRequests - 현재 요청 수
   */
  announceRateStatus(identifier, currentRequests) {
    const remaining = this.maxRequests - currentRequests;
    const statusMessage = `API 요청 상태: ${currentRequests}/${this.maxRequests}개 사용됨. ${remaining}개 남음`;
    
    // ARIA live region에 상태 업데이트
    const statusElement = document.getElementById('rate-limit-status');
    if (statusElement) {
      statusElement.textContent = statusMessage;
      statusElement.setAttribute('aria-live', 'polite');
    }
  }
  
  /**
   * 리소스 정리 (Alpine.js cleanup 시 호출)
   */
  destroy() {
    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval);
      this.cleanupInterval = null;
    }
    
    this.requests.clear();
    console.log('RateLimiter 리소스 정리 완료');
  }
}

/**
 * AI 생성 서비스 유틸리티 함수들 (JavaScript/Alpine.js 버전)
 */
const AIGenerationUtils = {
  /**
   * Supabase Edge Function을 통한 AI API 호출
   * @param {string} functionName - Edge Function 이름
   * @param {Object} payload - 요청 데이터
   * @returns {Promise<Object>} AI 응답 데이터
   */
  async callSupabaseEdgeFunction(functionName, payload) {
    try {
      // UTF-8 안전성 검증
      if (!this.validateObjectUTF8(payload)) {
        throw new Error('요청 데이터 UTF-8 인코딩 오류');
      }
      
      const { data, error } = await supabase.functions.invoke(functionName, {
        body: JSON.stringify(payload),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${await supabase.auth.getSession().access_token}`
        }
      });

      if (error) {
        throw new Error(`AI API 호출 실패: ${error.message}`);
      }

      return data;
    } catch (error) {
      console.error('Edge Function 호출 오류:', error);
      throw error;
    }
  },

  /**
   * 컨텍스트 사용 이력 저장
   * @param {string} studentId - 학생 ID
   * @param {Object} context - 학생 컨텍스트 데이터
   * @param {Object} mappedData - 매핑된 데이터
   * @param {Object} result - AI 생성 결과
   */
  async saveContextUsage(studentId, context, mappedData, result) {
    try {
      const { data: { user } } = await supabase.auth.getUser();
      
      const { error } = await supabase.from('ai_generation_contexts').insert({
        student_id: studentId,
        user_id: user?.id,
        service_type: result.serviceType || 'unknown',
        generation_id: result.generationId,
        context_snapshot: context,
        mapped_data: mappedData,
        context_influence_score: result.contextInfluenceScore || 0.8,
        data_sources: this.extractDataSources(context)
      });
      
      if (error) {
        throw new Error(`컨텍스트 사용 이력 저장 실패: ${error.message}`);
      }
    } catch (error) {
      console.error('컨텍스트 사용 이력 저장 오류:', error);
      // 비중요한 오류이므로 에러를 던지지 않음
    }
  },

  /**
   * 사용된 데이터 소스 추출
   * @param {Object} context - 학생 컨텍스트 데이터
   * @returns {Array<string>} 데이터 소스 목록
   */
  extractDataSources(context) {
    const sources = [];
    
    if (context.profile) sources.push('student_profile');
    if (context.currentLevels && Object.keys(context.currentLevels).length > 0) {
      sources.push('current_levels');
    }
    if (context.recentAssessments?.length > 0) sources.push('recent_assessments');
    if (context.counselingHistory?.length > 0) sources.push('counseling_history');
    if (context.medicalInfo?.diagnosis?.length > 0) sources.push('medical_info');
    
    return sources;
  },
  
  /**
   * 객체의 UTF-8 안전성 검증
   * @param {Object} obj - 검증할 객체
   * @returns {boolean} 안전한 UTF-8 객체 여부
   */
  validateObjectUTF8(obj) {
    try {
      const jsonString = JSON.stringify(obj);
      const encoded = new TextEncoder().encode(jsonString);
      const decoded = new TextDecoder('utf-8', { fatal: true }).decode(encoded);
      return JSON.parse(decoded) !== null;
    } catch (error) {
      console.error('객체 UTF-8 검증 실패:', error);
      return false;
    }
  }
};
```

### 9.2.2 학생 컨텍스트 빌더 (Alpine.js/JavaScript 구조)

#### 데이터 팩토리 함수들
```javascript
/**
 * 캐시된 컨텍스트 팩토리 함수
 * @param {Object} context - 학생 컨텍스트 객체
 * @param {number} ttl - 캐시 유효 시간 (밀리초, 기본값: 30분)
 * @returns {Object} 캐시된 컨텍스트 구조
 */
function createCachedContext(context, ttl = 1800000) {
  const now = Date.now();
  return {
    context,
    expires: now + ttl,
    lastAccessed: now,
    createdAt: now,
    
    // 캐시 유효성 검사
    isValid() {
      return Date.now() < this.expires;
    },
    
    // 접근 시간 업데이트
    touch() {
      this.lastAccessed = Date.now();
    }
  };
}

/**
 * 학생 컨텍스트 팩토리 함수 (UTF-8 안전성 포함)
 * @param {Object} profile - 학생 프로필
 * @param {Object} currentLevels - 현행 수준 데이터
 * @param {Array} recentAssessments - 최근 평가 목록
 * @param {Object} individualization - 개별화 데이터
 * @param {Array} counselingHistory - 상담 이력
 * @param {Object} medicalInfo - 의료 정보
 * @returns {Object} 학생 컨텍스트 구조
 */
function createStudentContext({
  profile,
  currentLevels = {},
  recentAssessments = [],
  individualization = null,
  counselingHistory = [],
  medicalInfo = null
}) {
  return {
    profile,
    currentLevels,
    recentAssessments,
    individualization: individualization || createIndividualizationData({}),
    counselingHistory,
    medicalInfo: medicalInfo || createMedicalInfo({}),
    buildTimestamp: new Date().toISOString(),
    dataCompleteness: calculateDataCompleteness({
      profile,
      currentLevels,
      recentAssessments,
      individualization,
      counselingHistory,
      medicalInfo
    }),
    
    // UTF-8 안전성 검증
    validateEncoding() {
      try {
        const jsonString = JSON.stringify(this);
        const encoded = new TextEncoder().encode(jsonString);
        const decoded = new TextDecoder('utf-8', { fatal: true }).decode(encoded);
        return JSON.parse(decoded) !== null;
      } catch (error) {
        console.error('학생 컨텍스트 UTF-8 검증 실패:', error);
        return false;
      }
    }
  };
}

/**
 * 학생 프로필 팩토리 함수 (UTF-8 안전성 포함)
 */
function createStudentProfile(data = {}) {
  return {
    id: data.id || '',
    name: data.name || '',
    birthDate: data.birthDate || null,
    gender: data.gender || 'unknown', // 'male', 'female', 'other', 'unknown'
    grade: data.grade || 1,
    className: data.className || '',
    disabilityType: data.disabilityType || [],
    disabilityLevel: data.disabilityLevel || 'unknown', // 'mild', 'moderate', 'severe', 'unknown'
    supportNeeds: data.supportNeeds || [],
    learningStyle: data.learningStyle || [],
    strengths: data.strengths || [],
    challenges: data.challenges || [],
    accommodationNeeds: data.accommodationNeeds || [],
    medicalConditions: data.medicalConditions || [],
    emergencyContact: data.emergencyContact || null,
    parentInfo: data.parentInfo || null,
    createdAt: data.createdAt || new Date().toISOString(),
    updatedAt: data.updatedAt || new Date().toISOString(),
    
    // 한글 데이터 UTF-8 안전성 검증
    validateUTF8() {
      const textFields = [this.name, this.className, ...this.strengths, ...this.challenges];
      return textFields.every(field => {
        if (!field) return true;
        try {
          const encoded = new TextEncoder().encode(field);
          const decoded = new TextDecoder('utf-8', { fatal: true }).decode(encoded);
          return decoded === field;
        } catch { return false; }
      });
    }
  };
}

/**
 * 현행수준 팩토리 함수
 */
function createCurrentLevel(data = {}) {
  return {
    id: data.id || '',
    studentId: data.studentId || '',
    subject: data.subject || '',
    academicLevel: data.academicLevel || '',
    detailedLevel: data.detailedLevel || '',
    assessmentDate: data.assessmentDate || new Date().toISOString().split('T')[0],
    assessmentMethod: data.assessmentMethod || '',
    strengths: data.strengths || [],
    areasForImprovement: data.areasForImprovement || [],
    notes: data.notes || null,
    createdAt: data.createdAt || new Date().toISOString(),
    updatedAt: data.updatedAt || new Date().toISOString()
  };
}

/**
 * 평가 팩토리 함수
 */
function createAssessment(data = {}) {
  return {
    id: data.id || '',
    studentId: data.studentId || '',
    subject: data.subject || '',
    evaluationMonth: data.evaluationMonth || new Date().toISOString().substring(0, 7),
    achievementLevel: data.achievementLevel || '',
    detailedEvaluation: data.detailedEvaluation || '',
    strengths: data.strengths || [],
    areasForImprovement: data.areasForImprovement || [],
    nextMonthGoals: data.nextMonthGoals || [],
    teacherNotes: data.teacherNotes || null,
    createdAt: data.createdAt || new Date().toISOString(),
    updatedAt: data.updatedAt || new Date().toISOString()
  };
}

/**
 * 상담 기록 팩토리 함수
 */
function createCounselingRecord(data = {}) {
  return {
    id: data.id || '',
    studentId: data.studentId || '',
    counselingDate: data.counselingDate || new Date().toISOString().split('T')[0],
    counselingType: data.counselingType || '',
    participants: data.participants || [],
    mainTopics: data.mainTopics || [],
    keyInsights: data.keyInsights || [],
    actionItems: data.actionItems || [],
    followUpNeeded: data.followUpNeeded || false,
    emotionalState: data.emotionalState || null,
    behavioralObservations: data.behavioralObservations || [],
    recommendations: data.recommendations || [],
    createdAt: data.createdAt || new Date().toISOString(),
    updatedAt: data.updatedAt || new Date().toISOString()
  };
}

/**
 * 의료 정보 팩토리 함수
 */
function createMedicalInfo(data = {}) {
  return {
    conditions: data.conditions || [],
    medications: data.medications || [],
    allergies: data.allergies || [],
    specialNeeds: data.specialNeeds || [],
    lastUpdated: data.lastUpdated || new Date().toISOString()
  };
}

/**
 * 개별화 데이터 팩토리 함수
 */
function createIndividualizationData(data = {}) {
  return {
    learningStyle: data.learningStyle || [],
    strengths: data.strengths || [],
    challenges: data.challenges || [],
    supportNeeds: data.supportNeeds || [],
    accommodationNeeds: data.accommodationNeeds || [],
    learningPreferences: data.learningPreferences || createLearningPreferences({}),
    adaptationStrategies: data.adaptationStrategies || [],
    motivationalFactors: data.motivationalFactors || [],
    communicationStyle: data.communicationStyle || createCommunicationStyle({}),
    socialInteractionLevel: data.socialInteractionLevel || createSocialInteractionLevel({})
  };
}

/**
 * 학습 선호도 팩토리 함수
 */
function createLearningPreferences(data = {}) {
  return {
    visualAids: data.visualAids || false,
    auditorySupport: data.auditorySupport || false,
    handsOnLearning: data.handsOnLearning || false,
    structuredEnvironment: data.structuredEnvironment || false,
    oneOnOneInstruction: data.oneOnOneInstruction || false,
    groupActivities: data.groupActivities || false,
    technologyAssisted: data.technologyAssisted || false,
    quietSpace: data.quietSpace || false
  };
}

/**
 * 커뮤니케이션 스타일 팩토리 함수
 */
function createCommunicationStyle(data = {}) {
  return {
    verbalCommunication: data.verbalCommunication || 'basic', // 'none', 'basic', 'advanced'
    nonVerbalCues: data.nonVerbalCues || 'some', // 'none', 'some', 'many'
    assistiveTechnology: data.assistiveTechnology || [],
    preferredLanguage: data.preferredLanguage || 'korean',
    comprehensionLevel: data.comprehensionLevel || 'grade-appropriate' // 'below-grade', 'grade-appropriate', 'above-grade'
  };
}

/**
 * 사회적 상호작용 레벨 팩토리 함수
 */
function createSocialInteractionLevel(data = {}) {
  return {
    peerInteraction: data.peerInteraction || 'limited', // 'minimal', 'limited', 'moderate', 'high'
    adultInteraction: data.adultInteraction || 'moderate', // 'minimal', 'limited', 'moderate', 'high'
    groupParticipation: data.groupParticipation || 'with-support', // 'none', 'with-support', 'independent'
    socialSkillsLevel: data.socialSkillsLevel || 'developing' // 'emerging', 'developing', 'established'
  };
}

/**
 * 지원 요구사항 팩토리 함수
 */
function createSupportNeed(data = {}) {
  return {
    type: data.type || '',
    description: data.description || '',
    priority: data.priority || 'medium', // 'low', 'medium', 'high'
    frequency: data.frequency || 'as-needed' // 'daily', 'weekly', 'monthly', 'as-needed'
  };
}

/**
 * 데이터 완전성 계산 함수 (Alpine.js 호환)
 * @param {Object} contextData - 전체 컨텍스트 데이터
 * @returns {Object} 데이터 완전성 점수
 */
function calculateDataCompleteness(contextData) {
  const scores = {};
  let totalScore = 0;
  let totalWeight = 0;
  
  // 프로필 완전성 (30% 가중치)
  if (contextData.profile) {
    const profileFields = ['name', 'grade', 'className', 'disabilityType', 'supportNeeds'];
    const completedFields = profileFields.filter(field => 
      contextData.profile[field] && 
      (Array.isArray(contextData.profile[field]) ? 
        contextData.profile[field].length > 0 : 
        contextData.profile[field].toString().trim() !== '')
    ).length;
    scores.profile = Math.round((completedFields / profileFields.length) * 100);
    totalScore += scores.profile * 0.3;
    totalWeight += 0.3;
  }
  
  // 현행수준 완전성 (25% 가중치)
  if (contextData.currentLevels) {
    const levelCount = Object.keys(contextData.currentLevels).length;
    scores.currentLevels = Math.min(levelCount * 20, 100); // 5과목 이상이면 100%
    totalScore += scores.currentLevels * 0.25;
    totalWeight += 0.25;
  }
  
  // 최근 평가 완전성 (20% 가중치)
  if (contextData.recentAssessments) {
    scores.recentAssessments = Math.min(contextData.recentAssessments.length * 25, 100);
    totalScore += scores.recentAssessments * 0.2;
    totalWeight += 0.2;
  }
  
  // 개별화 데이터 완전성 (15% 가중치)
  if (contextData.individualization) {
    const indivFields = ['learningStyle', 'strengths', 'challenges', 'accommodationNeeds'];
    const completedIndivFields = indivFields.filter(field =>
      contextData.individualization[field] && 
      contextData.individualization[field].length > 0
    ).length;
    scores.individualization = Math.round((completedIndivFields / indivFields.length) * 100);
    totalScore += scores.individualization * 0.15;
    totalWeight += 0.15;
  }
  
  // 상담 이력 완전성 (10% 가중치)
  if (contextData.counselingHistory) {
    scores.counselingHistory = Math.min(contextData.counselingHistory.length * 50, 100);
    totalScore += scores.counselingHistory * 0.1;
    totalWeight += 0.1;
  }
  
  return {
    ...scores,
    overall: totalWeight > 0 ? Math.round(totalScore / totalWeight) : 0,
    lastCalculated: new Date().toISOString()
  };
}

/**
 * 지원 요구사항 데이터 구조
 * @typedef {Object} SupportNeed
 * @property {string} type - 지원 유형
 * @property {string} description - 지원 설명
 * @property {'low'|'medium'|'high'} priority - 우선순위 (낮음|보통|높음)
 * @property {'daily'|'weekly'|'monthly'|'as-needed'} frequency - 지원 빈도
 */

/**
 * 학습 선호도 데이터 구조
 * @typedef {Object} LearningPreferences
 * @property {boolean} visualLearning - 시각적 학습 선호도
 * @property {boolean} auditoryLearning - 청각적 학습 선호도
 * @property {boolean} kinestheticLearning - 신체적 학습 선호도
 * @property {'slow'|'moderate'|'fast'} preferredPace - 선호 학습 속도
 * @property {'short'|'average'|'long'} attentionSpan - 집중력 지속시간
 * @property {'independent'|'collaborative'|'guided'} workingStyle - 학습 스타일
 */

/**
 * 적응 전략 데이터 구조
 * @typedef {Object} AdaptationStrategy
 * @property {string} strategy - 적응 전략명
 * @property {string} description - 전략 설명
 * @property {Array<string>} applicableSubjects - 적용 가능한 과목 목록
  effectiveness: 'low' | 'medium' | 'high';
}

/**
 * 동기 부여 요소 인터페이스
 */
interface MotivationalFactor {
  factor: string;
  description: string;
  strength: 'low' | 'medium' | 'high';
}

/**
 * 의사소통 스타일 인터페이스
 */
interface CommunicationStyle {
  preferredMethod: 'verbal' | 'visual' | 'written' | 'gestural';
  clarity: 'simple' | 'clear' | 'detailed';
  pace: 'slow' | 'moderate' | 'fast';
  supportNeeds: string[];
}

/**
 * 사회적 상호작용 수준 인터페이스
 */
interface SocialInteractionLevel {
  level: 'low' | 'moderate' | 'high';
  preferences: string[];
  challenges: string[];
  strengths: string[];
}

/**
 * 데이터 완전성 인터페이스
 */
interface DataCompleteness {
  overall: number;
  breakdown: {
    profile: number;
    currentLevels: number;
    assessments: number;
    counseling: number;
    medicalInfo: number;
  };
  missingCriticalData: string[];
  recommendations: string[];
}

/**
 * 연락처 정보 인터페이스
 */
interface ContactInfo {
  name: string;
  relationship: string;
  phone: string;
  email?: string;
}

/**
 * 부모 정보 인터페이스
 */
interface ParentInfo {
  father?: ContactInfo;
  mother?: ContactInfo;
  guardian?: ContactInfo;
}

/**
 * 학생 컨텍스트 에러 클래스
 */
class StudentContextError extends Error {
  public readonly code: string;
  public readonly context?: any;
  public readonly timestamp: string;

  constructor(message: string, code: string, context?: any) {
    super(message);
    this.name = 'StudentContextError';
    this.code = code;
    this.context = context;
    this.timestamp = new Date().toISOString();

    // Error 클래스 상속 시 필요한 설정
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, StudentContextError);
    }
  }

  /**
   * 에러 정보를 JSON 형태로 직렬화
   */
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      code: this.code,
      context: this.context,
      timestamp: this.timestamp,
      stack: this.stack
    };
  }

  /**
   * 사용자 친화적인 에러 메시지 생성
   */
  getUserFriendlyMessage(): string {
    switch (this.code) {
      case 'INVALID_STUDENT_ID':
        return '올바르지 않은 학생 정보입니다. 다시 확인해 주세요.';
      case 'STUDENT_NOT_FOUND':
        return '해당 학생을 찾을 수 없습니다.';
      case 'CONTEXT_BUILD_FAILED':
        return '학생 정보를 불러오는 중 오류가 발생했습니다.';
      case 'AUTH_REQUIRED':
        return '로그인이 필요합니다.';
      default:
        return '시스템 오류가 발생했습니다. 관리자에게 문의해 주세요.';
    }
  }
}
```

#### 구현 클래스
```javascript
/**
 * 학생 컨텍스트 구축 및 캐시 관리 클래스
 * 고성능 캐싱, 완전한 에러 처리, 메모리 관리 포함
 */
class StudentContextBuilder {
  private memoryCache: Map<string, CachedContext> = new Map();
  private readonly CACHE_DURATION = 30 * 60 * 1000; // 30분
  private readonly MAX_CACHE_SIZE = 100; // 최대 캐시 항목 수
  private readonly CLEANUP_INTERVAL = 5 * 60 * 1000; // 5분마다 정리
  private cleanupTimer: NodeJS.Timeout | null = null;
  
  constructor() {
    this.startCacheCleanup();
  }

  /**
   * 학생 컨텍스트 구축 (캐시 활용)
   * @param studentId 학생 ID
   * @param forceRefresh 강제 새로고침 여부
   * @returns 학생 컨텍스트
   */
  async buildContext(studentId: string, forceRefresh: boolean = false): Promise<StudentContext> {
    try {
      // 입력 검증
      if (!studentId || typeof studentId !== 'string') {
        throw new StudentContextError('유효하지 않은 학생 ID입니다.', 'INVALID_STUDENT_ID');
      }

      // 강제 새로고침이 아닌 경우 캐시 확인
      if (!forceRefresh) {
        // 1. 메모리 캐시 확인
        const memoryCached = this.getFromMemoryCache(studentId);
        if (memoryCached) {
          return memoryCached;
        }

        // 2. DB 캐시 확인
        const dbCached = await this.getFromDBCache(studentId);
        if (dbCached) {
          this.setMemoryCache(studentId, dbCached);
          return dbCached;
        }
      }

      // 3. 새로운 컨텍스트 구축
      const context = await this.buildFreshContext(studentId);
      
      // 4. 캐시에 저장 (병렬 처리)
      await Promise.all([
        this.saveToDBCache(studentId, context),
        Promise.resolve(this.setMemoryCache(studentId, context))
      ]);

      return context;
      
    } catch (error) {
      if (error instanceof StudentContextError) {
        throw error;
      }
      throw new StudentContextError(
        `학생 컨텍스트 구축 실패: ${error.message}`,
        'CONTEXT_BUILD_FAILED',
        { studentId, originalError: error }
      );
    }
  }

  /**
   * 메모리 캐시에서 컨텍스트 조회
   */
  private getFromMemoryCache(studentId: string): StudentContext | null {
    const cached = this.memoryCache.get(studentId);
    if (!cached) return null;

    // 만료 확인
    if (cached.expires <= Date.now()) {
      this.memoryCache.delete(studentId);
      return null;
    }

    // 접근 시간 업데이트 (LRU 구현)
    cached.lastAccessed = Date.now();
    return cached.context;
  }

  /**
   * 메모리 캐시에 컨텍스트 저장
   */
  private setMemoryCache(studentId: string, context: StudentContext): void {
    // 캐시 크기 제한 확인
    if (this.memoryCache.size >= this.MAX_CACHE_SIZE) {
      this.evictLeastRecentlyUsed();
    }

    const now = Date.now();
    this.memoryCache.set(studentId, {
      context: this.deepClone(context), // 깊은 복사로 불변성 보장
      expires: now + this.CACHE_DURATION,
      lastAccessed: now,
      createdAt: now
    });
  }

  /**
   * LRU 알고리즘으로 가장 오래된 캐시 항목 제거
   */
  private evictLeastRecentlyUsed(): void {
    let oldestKey = '';
    let oldestTime = Date.now();

    for (const [key, cached] of this.memoryCache.entries()) {
      if (cached.lastAccessed < oldestTime) {
        oldestTime = cached.lastAccessed;
        oldestKey = key;
      }
    }

    if (oldestKey) {
      this.memoryCache.delete(oldestKey);
    }
  }

  /**
   * DB 캐시에서 컨텍스트 조회
   */
  private async getFromDBCache(studentId: string): Promise<StudentContext | null> {
    try {
      const { data, error } = await supabase
        .from('student_context_cache')
        .select('context_data, context_version, expires_at')
        .eq('student_id', studentId)
        .eq('user_id', (await supabase.auth.getUser()).data.user?.id)
        .eq('is_valid', true)
        .gt('expires_at', new Date().toISOString())
        .order('created_at', { ascending: false })
        .limit(1)
        .single();

      if (error) {
        if (error.code === 'PGRST116') { // No rows found
          return null;
        }
        throw error;
      }

      if (!data?.context_data) {
        return null;
      }

      // 컨텍스트 버전 호환성 확인
      if (!this.isContextVersionCompatible(data.context_version)) {
        await this.invalidateDBCache(studentId);
        return null;
      }

      return this.validateAndSanitizeContext(data.context_data);
      
    } catch (error) {
      console.error('DB 캐시 조회 실패:', error);
      return null; // 캐시 실패 시 새로 구축
    }
  }

  /**
   * DB 캐시에 컨텍스트 저장
   */
  private async saveToDBCache(studentId: string, context: StudentContext): Promise<void> {
    try {
      const user = (await supabase.auth.getUser()).data.user;
      if (!user) {
        throw new StudentContextError('사용자 인증이 필요합니다.', 'AUTH_REQUIRED');
      }

      // 기존 캐시 무효화
      await this.invalidateDBCache(studentId);

      // 새 캐시 저장
      const { error } = await supabase
        .from('student_context_cache')
        .insert({
          student_id: studentId,
          user_id: user.id,
          context_data: context,
          context_version: '1.0',
          expires_at: new Date(Date.now() + this.CACHE_DURATION).toISOString(),
          last_updated_source: 'full_rebuild',
          is_valid: true
        });

      if (error) {
        throw error;
      }
      
    } catch (error) {
      console.error('DB 캐시 저장 실패:', error);
      // DB 캐시 저장 실패는 치명적이지 않으므로 에러를 던지지 않음
    }
  }

  /**
   * 새로운 컨텍스트 구축
   */
  private async buildFreshContext(studentId: string): Promise<StudentContext> {
    try {
      // 병렬로 모든 데이터 조회
      const [profile, currentLevels, assessments, counseling, medicalInfo] = await Promise.allSettled([
        this.getStudentProfile(studentId),
        this.getCurrentLevels(studentId),
        this.getRecentAssessments(studentId),
        this.getCounselingHistory(studentId),
        this.getMedicalInfo(studentId)
      ]);

      // 실패한 요청 처리
      const resolvedProfile = this.handleSettledResult(profile, 'profile');
      const resolvedCurrentLevels = this.handleSettledResult(currentLevels, 'currentLevels');
      const resolvedAssessments = this.handleSettledResult(assessments, 'assessments');
      const resolvedCounseling = this.handleSettledResult(counseling, 'counseling');
      const resolvedMedicalInfo = this.handleSettledResult(medicalInfo, 'medicalInfo');

      // 개별화 정보 추출
      const individualization = this.extractIndividualization(
        resolvedProfile,
        resolvedCurrentLevels,
        resolvedAssessments
      );

      return {
        profile: resolvedProfile,
        currentLevels: this.mapCurrentLevelsBySubject(resolvedCurrentLevels),
        recentAssessments: resolvedAssessments,
        individualization,
        counselingHistory: resolvedCounseling,
        medicalInfo: resolvedMedicalInfo,
        buildTimestamp: new Date().toISOString(),
        dataCompleteness: this.calculateDataCompleteness({
          profile: resolvedProfile,
          currentLevels: resolvedCurrentLevels,
          assessments: resolvedAssessments,
          counseling: resolvedCounseling,
          medicalInfo: resolvedMedicalInfo
        })
      };
      
    } catch (error) {
      throw new StudentContextError(
        `새로운 컨텍스트 구축 실패: ${error.message}`,
        'FRESH_CONTEXT_BUILD_FAILED',
        { studentId }
      );
    }
  }

  /**
   * 학생 프로필 조회
   */
  private async getStudentProfile(studentId: string): Promise<StudentProfile> {
    const { data, error } = await supabase
      .from('students')
      .select(`
        id, name, birth_date, gender, grade, class_name,
        disability_type, disability_level, support_needs,
        learning_style, strengths, challenges,
        accommodation_needs, medical_conditions,
        emergency_contact, parent_info,
        created_at, updated_at
      `)
      .eq('id', studentId)
      .single();

    if (error) {
      throw new StudentContextError(
        `학생 프로필 조회 실패: ${error.message}`,
        'PROFILE_FETCH_FAILED',
        { studentId }
      );
    }

    if (!data) {
      throw new StudentContextError(
        '학생을 찾을 수 없습니다.',
        'STUDENT_NOT_FOUND',
        { studentId }
      );
    }

    return {
      id: data.id,
      name: data.name,
      birthDate: data.birth_date,
      gender: data.gender,
      grade: data.grade,
      className: data.class_name,
      disabilityType: data.disability_type,
      disabilityLevel: data.disability_level,
      supportNeeds: data.support_needs || [],
      learningStyle: data.learning_style,
      strengths: data.strengths || [],
      challenges: data.challenges || [],
      accommodationNeeds: data.accommodation_needs || [],
      medicalConditions: data.medical_conditions || [],
      emergencyContact: data.emergency_contact,
      parentInfo: data.parent_info,
      createdAt: data.created_at,
      updatedAt: data.updated_at
    };
  }

  /**
   * 현행수준 조회
   */
  private async getCurrentLevels(studentId: string): Promise<CurrentLevel[]> {
    const { data, error } = await supabase
      .from('current_levels')
      .select(`
        id, student_id, subject, academic_level,
        detailed_level, assessment_date, assessment_method,
        strengths, areas_for_improvement, notes,
        created_at, updated_at
      `)
      .eq('student_id', studentId)
      .order('assessment_date', { ascending: false });

    if (error) {
      throw new StudentContextError(
        `현행수준 조회 실패: ${error.message}`,
        'CURRENT_LEVELS_FETCH_FAILED',
        { studentId }
      );
    }

    return (data || []).map(item => ({
      id: item.id,
      studentId: item.student_id,
      subject: item.subject,
      academicLevel: item.academic_level,
      detailedLevel: item.detailed_level,
      assessmentDate: item.assessment_date,
      assessmentMethod: item.assessment_method,
      strengths: item.strengths || [],
      areasForImprovement: item.areas_for_improvement || [],
      notes: item.notes,
      createdAt: item.created_at,
      updatedAt: item.updated_at
    }));
  }

  /**
   * 최근 평가 조회 (최근 3개월)
   */
  private async getRecentAssessments(studentId: string): Promise<Assessment[]> {
    const threeMonthsAgo = new Date();
    threeMonthsAgo.setMonth(threeMonthsAgo.getMonth() - 3);

    const { data, error } = await supabase
      .from('monthly_evaluations')
      .select(`
        id, student_id, subject, evaluation_month,
        achievement_level, detailed_evaluation,
        strengths, areas_for_improvement,
        next_month_goals, teacher_notes,
        created_at, updated_at
      `)
      .eq('student_id', studentId)
      .gte('evaluation_month', threeMonthsAgo.toISOString().slice(0, 7))
      .order('evaluation_month', { ascending: false });

    if (error) {
      throw new StudentContextError(
        `최근 평가 조회 실패: ${error.message}`,
        'ASSESSMENTS_FETCH_FAILED',
        { studentId }
      );
    }

    return (data || []).map(item => ({
      id: item.id,
      studentId: item.student_id,
      subject: item.subject,
      evaluationMonth: item.evaluation_month,
      achievementLevel: item.achievement_level,
      detailedEvaluation: item.detailed_evaluation,
      strengths: item.strengths || [],
      areasForImprovement: item.areas_for_improvement || [],
      nextMonthGoals: item.next_month_goals || [],
      teacherNotes: item.teacher_notes,
      createdAt: item.created_at,
      updatedAt: item.updated_at
    }));
  }

  /**
   * 상담 이력 조회 (최근 6개월)
   */
  private async getCounselingHistory(studentId: string): Promise<CounselingRecord[]> {
    const sixMonthsAgo = new Date();
    sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);

    const { data, error } = await supabase
      .from('counseling_records')
      .select(`
        id, student_id, counseling_date, counseling_type,
        participants, main_topics, key_insights,
        action_items, follow_up_needed,
        emotional_state, behavioral_observations,
        recommendations, created_at, updated_at
      `)
      .eq('student_id', studentId)
      .gte('counseling_date', sixMonthsAgo.toISOString())
      .order('counseling_date', { ascending: false });

    if (error) {
      throw new StudentContextError(
        `상담 이력 조회 실패: ${error.message}`,
        'COUNSELING_FETCH_FAILED',
        { studentId }
      );
    }

    return (data || []).map(item => ({
      id: item.id,
      studentId: item.student_id,
      counselingDate: item.counseling_date,
      counselingType: item.counseling_type,
      participants: item.participants || [],
      mainTopics: item.main_topics || [],
      keyInsights: item.key_insights || [],
      actionItems: item.action_items || [],
      followUpNeeded: item.follow_up_needed,
      emotionalState: item.emotional_state,
      behavioralObservations: item.behavioral_observations || [],
      recommendations: item.recommendations || [],
      createdAt: item.created_at,
      updatedAt: item.updated_at
    }));
  }

  /**
   * 의료 정보 조회
   */
  private async getMedicalInfo(studentId: string): Promise<MedicalInfo> {
    // 학생 프로필에서 의료 정보 추출
    const profile = await this.getStudentProfile(studentId);
    
    return {
      conditions: profile.medicalConditions,
      medications: [], // 필요시 별도 테이블에서 조회
      allergies: [], // 필요시 별도 테이블에서 조회
      specialNeeds: profile.supportNeeds.filter(need => 
        need.type === 'medical' || need.type === 'health'
      ),
      lastUpdated: profile.updatedAt
    };
  }

  /**
   * 컨텍스트 무효화
   */
  async invalidateContext(studentId: string): Promise<void> {
    // 메모리 캐시 제거
    this.memoryCache.delete(studentId);
    
    // DB 캐시 무효화
    await this.invalidateDBCache(studentId);
  }

  /**
   * DB 캐시 무효화
   */
  private async invalidateDBCache(studentId: string): Promise<void> {
    try {
      const user = (await supabase.auth.getUser()).data.user;
      if (!user) return;

      await supabase
        .from('student_context_cache')
        .update({ is_valid: false })
        .eq('student_id', studentId)
        .eq('user_id', user.id);
    } catch (error) {
      console.error('DB 캐시 무효화 실패:', error);
    }
  }

  /**
   * 컨텍스트 버전 호환성 확인
   */
  private isContextVersionCompatible(version: string): boolean {
    const currentVersion = '1.0';
    const supportedVersions = ['1.0'];
    return supportedVersions.includes(version);
  }

  /**
   * 컨텍스트 검증 및 살균화
   */
  private validateAndSanitizeContext(contextData: any): StudentContext {
    // 기본 구조 검증
    if (!contextData || typeof contextData !== 'object') {
      throw new StudentContextError('잘못된 컨텍스트 데이터 형식입니다.', 'INVALID_CONTEXT_FORMAT');
    }

    // 필수 필드 검증
    const requiredFields = ['profile', 'currentLevels', 'individualization'];
    for (const field of requiredFields) {
      if (!contextData[field]) {
        throw new StudentContextError(`필수 필드가 누락되었습니다: ${field}`, 'MISSING_REQUIRED_FIELD');
      }
    }

    return contextData as StudentContext;
  }

  /**
   * Promise.allSettled 결과 처리
   */
  private handleSettledResult<T>(result: PromiseSettledResult<T>, dataType: string): T {
    if (result.status === 'fulfilled') {
      return result.value;
    } else {
      console.error(`${dataType} 데이터 조회 실패:`, result.reason);
      // 기본값 반환 (데이터 타입에 따라)
      return this.getDefaultValueForDataType(dataType);
    }
  }

  /**
   * 데이터 타입별 기본값 반환
   */
  private getDefaultValueForDataType(dataType: string): any {
    switch (dataType) {
      case 'profile':
        return {
          id: '',
          name: '알 수 없음',
          birthDate: null,
          gender: 'unknown',
          grade: 0,
          className: '',
          disabilityType: [],
          disabilityLevel: 'unknown',
          supportNeeds: [],
          learningStyle: [],
          strengths: [],
          challenges: [],
          accommodationNeeds: [],
          medicalConditions: [],
          emergencyContact: null,
          parentInfo: null,
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString()
        };
      case 'currentLevels':
      case 'assessments':
      case 'counseling':
        return [];
      case 'medicalInfo':
        return {
          conditions: [],
          medications: [],
          allergies: [],
          specialNeeds: [],
          lastUpdated: new Date().toISOString()
        };
      default:
        return null;
    }
  }

  /**
   * 개별화 정보 추출
   */
  private extractIndividualization(
    profile: StudentProfile,
    currentLevels: CurrentLevel[],
    assessments: Assessment[]
  ): IndividualizationData {
    // 모든 과목의 강점과 어려움 영역 수집
    const allStrengths = new Set<string>();
    const allChallenges = new Set<string>();
    
    // 프로필에서 기본 정보 추출
    profile.strengths.forEach(strength => allStrengths.add(strength));
    profile.challenges.forEach(challenge => allChallenges.add(challenge));
    
    // 현행수준에서 정보 추출
    currentLevels.forEach(level => {
      level.strengths.forEach(strength => allStrengths.add(strength));
      level.areasForImprovement.forEach(area => allChallenges.add(area));
    });
    
    // 최근 평가에서 정보 추출
    assessments.forEach(assessment => {
      assessment.strengths.forEach(strength => allStrengths.add(strength));
      assessment.areasForImprovement.forEach(area => allChallenges.add(area));
    });

    // 학습 선호도 분석
    const learningPreferences = this.analyzeLearningPreferences(profile, assessments);
    
    // 지원 요구사항 분석
    const supportNeeds = this.analyzeSupportNeeds(profile, currentLevels);
    
    // 적응 전략 추천
    const adaptationStrategies = this.recommendAdaptationStrategies(
      profile, currentLevels, assessments
    );

    return {
      learningStyle: profile.learningStyle,
      strengths: Array.from(allStrengths),
      challenges: Array.from(allChallenges),
      supportNeeds,
      accommodationNeeds: profile.accommodationNeeds,
      learningPreferences,
      adaptationStrategies,
      motivationalFactors: this.identifyMotivationalFactors(assessments),
      communicationStyle: this.analyzeCommunicationStyle(profile),
      socialInteractionLevel: this.assessSocialInteractionLevel(profile)
    };
  }

  /**
   * 현행수준을 과목별로 매핑
   */
  private mapCurrentLevelsBySubject(currentLevels: CurrentLevel[]): { [subject: string]: CurrentLevel } {
    const mapped: { [subject: string]: CurrentLevel } = {};
    
    // 각 과목별로 가장 최근 평가 선택
    currentLevels.forEach(level => {
      const existing = mapped[level.subject];
      if (!existing || new Date(level.assessmentDate) > new Date(existing.assessmentDate)) {
        mapped[level.subject] = level;
      }
    });
    
    return mapped;
  }

  /**
   * 데이터 완전성 계산
   */
  private calculateDataCompleteness(data: {
    profile: StudentProfile;
    currentLevels: CurrentLevel[];
    assessments: Assessment[];
    counseling: CounselingRecord[];
    medicalInfo: MedicalInfo;
  }): DataCompleteness {
    const scores = {
      profile: this.calculateProfileCompleteness(data.profile),
      currentLevels: this.calculateCurrentLevelsCompleteness(data.currentLevels),
      assessments: this.calculateAssessmentsCompleteness(data.assessments),
      counseling: this.calculateCounselingCompleteness(data.counseling),
      medicalInfo: this.calculateMedicalInfoCompleteness(data.medicalInfo)
    };

    const overallScore = (scores.profile + scores.currentLevels + scores.assessments + scores.counseling + scores.medicalInfo) / 5;

    return {
      overall: overallScore,
      breakdown: scores,
      missingCriticalData: this.identifyMissingCriticalData(data),
      recommendations: this.generateDataImprovementRecommendations(scores)
    };
  }

  /**
   * 깊은 복사 (불변성 보장)
   */
  private deepClone<T>(obj: T): T {
    if (obj === null || typeof obj !== 'object') return obj;
    if (obj instanceof Date) return new Date(obj.getTime()) as any;
    if (obj instanceof Array) return obj.map(item => this.deepClone(item)) as any;
    if (typeof obj === 'object') {
      const cloned: any = {};
      for (const key in obj) {
        if (obj.hasOwnProperty(key)) {
          cloned[key] = this.deepClone(obj[key]);
        }
      }
      return cloned;
    }
    return obj;
  }

  /**
   * 캐시 정리 시작
   */
  private startCacheCleanup(): void {
    this.cleanupTimer = setInterval(() => {
      this.cleanupExpiredCache();
    }, this.CLEANUP_INTERVAL);
  }

  /**
   * 만료된 캐시 정리
   */
  private cleanupExpiredCache(): void {
    const now = Date.now();
    const expiredKeys: string[] = [];

    for (const [key, cached] of this.memoryCache.entries()) {
      if (cached.expires <= now) {
        expiredKeys.push(key);
      }
    }

    expiredKeys.forEach(key => this.memoryCache.delete(key));
  }

  /**
   * 리소스 정리
   */
  destroy(): void {
    if (this.cleanupTimer) {
      clearInterval(this.cleanupTimer);
      this.cleanupTimer = null;
    }
    this.memoryCache.clear();
  }

  // 추가 헬퍼 메서드들 (간략화를 피하기 위해 기본 구현체 제공)
  private analyzeLearningPreferences(profile: StudentProfile, assessments: Assessment[]): LearningPreferences {
    return {
      visualLearning: profile.learningStyle.includes('visual'),
      auditoryLearning: profile.learningStyle.includes('auditory'),
      kinestheticLearning: profile.learningStyle.includes('kinesthetic'),
      preferredPace: 'moderate',
      attentionSpan: 'average',
      workingStyle: 'independent'
    };
  }

  private analyzeSupportNeeds(profile: StudentProfile, currentLevels: CurrentLevel[]): SupportNeed[] {
    return profile.supportNeeds.map(need => ({
      type: need.type || 'general',
      description: need.description || '',
      priority: need.priority || 'medium',
      frequency: need.frequency || 'as-needed'
    }));
  }

  private recommendAdaptationStrategies(profile: StudentProfile, currentLevels: CurrentLevel[], assessments: Assessment[]): AdaptationStrategy[] {
    return [
      {
        strategy: '개별화 지원',
        description: '학생의 개별 특성에 맞는 맞춤형 지원',
        applicableSubjects: ['all'],
        effectiveness: 'high'
      }
    ];
  }

  private identifyMotivationalFactors(assessments: Assessment[]): MotivationalFactor[] {
    return [
      {
        factor: '성취감',
        description: '작은 성공 경험을 통한 동기 부여',
        strength: 'medium'
      }
    ];
  }

  private analyzeCommunicationStyle(profile: StudentProfile): CommunicationStyle {
    return {
      preferredMethod: 'verbal',
      clarity: 'clear',
      pace: 'moderate',
      supportNeeds: []
    };
  }

  private assessSocialInteractionLevel(profile: StudentProfile): SocialInteractionLevel {
    return {
      level: 'moderate',
      preferences: ['small-group'],
      challenges: [],
      strengths: []
    };
  }

  private calculateProfileCompleteness(profile: StudentProfile): number {
    const requiredFields = ['name', 'birthDate', 'grade', 'disabilityType'];
    const completedFields = requiredFields.filter(field => profile[field as keyof StudentProfile]);
    return (completedFields.length / requiredFields.length) * 100;
  }

  private calculateCurrentLevelsCompleteness(currentLevels: CurrentLevel[]): number {
    const requiredSubjects = ['korean', 'math'];
    const availableSubjects = [...new Set(currentLevels.map(level => level.subject))];
    const coverage = availableSubjects.filter(subject => requiredSubjects.includes(subject)).length;
    return (coverage / requiredSubjects.length) * 100;
  }

  private calculateAssessmentsCompleteness(assessments: Assessment[]): number {
    return assessments.length > 0 ? Math.min(assessments.length * 25, 100) : 0;
  }

  private calculateCounselingCompleteness(counseling: CounselingRecord[]): number {
    return counseling.length > 0 ? Math.min(counseling.length * 50, 100) : 0;
  }

  private calculateMedicalInfoCompleteness(medicalInfo: MedicalInfo): number {
    return medicalInfo.conditions.length > 0 ? 100 : 50;
  }

  private identifyMissingCriticalData(data: any): string[] {
    const missing: string[] = [];
    if (!data.profile.name) missing.push('학생 이름');
    if (!data.profile.disabilityType.length) missing.push('장애 유형');
    if (!data.currentLevels.length) missing.push('현행수준 정보');
    return missing;
  }

  private generateDataImprovementRecommendations(scores: any): string[] {
    const recommendations: string[] = [];
    if (scores.profile < 80) recommendations.push('학생 기본 정보 보완 필요');
    if (scores.currentLevels < 80) recommendations.push('현행수준 평가 업데이트 필요');
    if (scores.assessments < 60) recommendations.push('정기 평가 실시 권장');
    return recommendations;
  }
}
```

---

## 9.3 서비스별 구현 클래스

### 9.3.1 교육과정 배정 AI 서비스
```javascript
class CurriculumAssignmentAI extends AIGenerationService {
  constructor() {
    super(AIServiceType.CURRICULUM_ASSIGNMENT);
  }

  protected mapDataForService(
    context: StudentContext,
    requestData: CurriculumAssignmentRequest
  ): CurriculumAssignmentMappedData {
    return {
      // 현행수준 → 적정 단원 수준 매핑
      levelMapping: this.mapCurrentLevelToUnits(
        context.currentLevels[requestData.subject],
        requestData.availableUnits
      ),
      
      // 개별화 특성 → 배정 전략
      assignmentStrategy: this.determineAssignmentStrategy(context.individualization),
      
      // 이전 성과 → 진도 조절
      pacingRecommendation: this.analyzePacingFromHistory(context.recentAssessments),
      
      // 지원 요구사항 → 단원 조정
      accommodationNeeds: this.mapAccommodationsToUnits(
        context.individualization.accommodations,
        requestData.availableUnits
      )
    };
  }

  protected buildContextualPrompt(
    requestData: CurriculumAssignmentRequest,
    context: StudentContext,
    mappedData: CurriculumAssignmentMappedData,
    preferences?: UserPreferences
  ): string {
    return `
# 특수교육 개별화 교육과정 배정

## 학생 정보
- 이름: ${context.profile.name}
- 학년: ${context.profile.grade}학년
- 장애유형: ${context.profile.disability_types?.join(', ') || '없음'}
- 통합교육 형태: ${context.profile.inclusion_type || '완전통합'}

## 현행수준 분석
${this.formatCurrentLevels(context.currentLevels[requestData.subject])}

## 개별화 특성
- 강점 영역: ${context.individualization.strengths.join(', ')}
- 도전 영역: ${context.individualization.challenges.join(', ')}
- 지원 요구사항: ${context.individualization.supportNeeds.join(', ')}
- 보조 도구: ${context.individualization.accommodations.join(', ')}

## 배정 요청 정보
- 과목: ${requestData.subject}
- 학기: ${requestData.semester}
- 대상 단원: ${requestData.availableUnits.map(u => u.unit_name).join(', ')}

## 배정 전략 분석
- 학습 속도: ${mappedData.assignmentStrategy.pacing}
- 복잡도 수준: ${mappedData.assignmentStrategy.complexity}
- 지원 수준: ${mappedData.assignmentStrategy.supportLevel}

## 요청사항
위 정보를 바탕으로 학생에게 적합한 교육과정 단원을 월별로 배정해주세요.
각 단원별로 다음을 포함해주세요:
1. 배정 근거 (현행수준 및 개별화 특성 기반)
2. 예상 학습 기간
3. 필요한 지원 및 조정사항
4. 평가 방법 제안

${preferences?.curriculum_style ? `교사 선호 스타일: ${preferences.curriculum_style}` : ''}
`;
  }

  protected async validateAndEnhanceResult(
    aiResult: any,
    context: StudentContext
  ): Promise<AIGenerationResult> {
    // 결과 검증 로직
    const validatedAssignments = this.validateAssignments(aiResult.assignments, context);
    
    // 개별화 적합성 점수 계산
    const individualizationScore = this.calculateIndividualizationScore(
      validatedAssignments,
      context.individualization
    );

    return {
      generationId: aiResult.generationId,
      content: validatedAssignments,
      confidence: aiResult.confidence,
      contextInfluenceScore: individualizationScore,
      metadata: {
        serviceType: this.serviceType,
        dataSourcesUsed: this.extractDataSources(context),
        individualizationApplied: true
      }
    };
  }
}
```

### 9.3.2 교육계획 수립 AI 서비스
```javascript
class LessonPlanAI extends AIGenerationService {
  constructor() {
    super(AIServiceType.LESSON_PLAN);
  }

  protected mapDataForService(
    context: StudentContext,
    requestData: LessonPlanRequest
  ): LessonPlanMappedData {
    return {
      // 학습 스타일 → 교수법 매핑
      teachingMethods: this.mapLearningStyleToMethods(
        context.individualization.learningStyle
      ),
      
      // 현행수준 → 목표 설정
      objectives: this.generateIndividualizedObjectives(
        context.currentLevels[requestData.subject],
        requestData.unit
      ),
      
      // 특성 → 평가 방법
      assessmentAdaptations: this.mapCharacteristicsToAssessment(
        context.individualization
      ),
      
      // 지원 요구사항 → 수업 조정
      instructionalAccommodations: this.mapSupportNeedsToInstructions(
        context.individualization.supportNeeds,
        context.individualization.accommodations
      )
    };
  }

  protected buildContextualPrompt(
    requestData: LessonPlanRequest,
    context: StudentContext,
    mappedData: LessonPlanMappedData,
    preferences?: UserPreferences
  ): string {
    return `
# 개별화 교수학습 계획안 작성

## 학생 개별 정보
- 학생명: ${context.profile.name}
- 현재 수준: ${this.formatCurrentLevel(context.currentLevels[requestData.subject])}
- 학습 강점: ${context.individualization.strengths.join(', ')}
- 학습 어려움: ${context.individualization.challenges.join(', ')}
- 필요 지원: ${context.individualization.supportNeeds.join(', ')}

## 수업 기본 정보
- 과목: ${requestData.subject}
- 단원: ${requestData.unit}
- 차시: ${requestData.period}
- 수업 시간: ${requestData.duration}분

## 개별화 교수 전략
- 권장 교수법: ${mappedData.teachingMethods.join(', ')}
- 수업 조정사항: ${mappedData.instructionalAccommodations.join(', ')}
- 평가 조정사항: ${mappedData.assessmentAdaptations.methods.join(', ')}

## 개별화 목표
${mappedData.objectives.shortTerm.map(obj => `- ${obj}`).join('\n')}

## 요청사항
위 개별화 정보를 반영하여 다음을 포함한 상세한 교수학습 계획안을 작성해주세요:

1. **개별화 학습목표** (학생 수준에 맞는 구체적 목표)
2. **단계별 교수활동** (개별 특성을 고려한 활동)
3. **개별화 자료** (학생에게 적합한 교구 및 자료)
4. **평가 방법** (개별 특성을 고려한 평가)
5. **지원 방안** (필요한 지원 및 조정사항)

${preferences?.teaching_style ? `교사 선호 교수법: ${preferences.teaching_style}` : ''}
${preferences?.formality_level ? `문체: ${preferences.formality_level}` : ''}
`;
  }

  protected async validateAndEnhanceResult(
    aiResult: any,
    context: StudentContext
  ): Promise<AIGenerationResult> {
    // 개별화 적용도 검증
    const individualizationCheck = this.validateIndividualization(aiResult, context);
    
    // 실행 가능성 검증
    const feasibilityCheck = this.validateFeasibility(aiResult, context);
    
    // 결과 향상
    const enhancedResult = await this.enhanceWithContextualDetails(aiResult, context);

    return {
      generationId: aiResult.generationId,
      content: enhancedResult,
      confidence: aiResult.confidence * individualizationCheck.score,
      contextInfluenceScore: individualizationCheck.contextUsage,
      metadata: {
        serviceType: this.serviceType,
        individualizationApplied: individualizationCheck.applied,
        feasibilityScore: feasibilityCheck.score,
        enhancementsApplied: enhancedResult.enhancements
      }
    };
  }
}
```

---

## 9.4 통합 서비스 팩토리

### 9.4.1 AI 서비스 팩토리
```javascript
class AIServiceFactory {
  private static services: Map<AIServiceType, AIGenerationService> = new Map();

  static getService(serviceType: AIServiceType): AIGenerationService {
    if (!this.services.has(serviceType)) {
      this.services.set(serviceType, this.createService(serviceType));
    }
    return this.services.get(serviceType)!;
  }

  private static createService(serviceType: AIServiceType): AIGenerationService {
    switch (serviceType) {
      case AIServiceType.CURRICULUM_ASSIGNMENT:
        return new CurriculumAssignmentAI();
      case AIServiceType.LESSON_PLAN:
        return new LessonPlanAI();
      case AIServiceType.ASSESSMENT:
        return new AssessmentAI();
      case AIServiceType.ADMIN_DOCUMENT:
        return new AdminDocumentAI();
      case AIServiceType.COUNSELING_GUIDE:
        return new CounselingGuideAI();
      default:
        throw new Error(`지원하지 않는 AI 서비스 타입: ${serviceType}`);
    }
  }
}
```

### 9.4.2 통합 API 엔드포인트
```javascript
// POST /api/ai/generate-with-context
export async function POST(request: Request) {
  try {
    const { serviceType, studentId, requestData, teacherPreferences } = await request.json();
    
    // 서비스 인스턴스 가져오기
    const aiService = AIServiceFactory.getService(serviceType);
    
    // 컨텍스트 기반 생성 실행
    const result = await aiService.generateWithContext(
      studentId,
      requestData,
      teacherPreferences
    );
    
    return createSuccessResponse(result);
  } catch (error) {
    return createErrorResponse(
      'AI_GENERATION_WITH_CONTEXT_ERROR',
      'AI 생성 중 오류가 발생했습니다.',
      error
    );
  }
}
```

---

## 9.5 성능 최적화 및 모니터링

### 9.5.1 컨텍스트 캐싱 전략
- **메모리 캐시**: 30분 유효, 자주 사용되는 학생 컨텍스트
- **DB 캐시**: 1시간 유효, 모든 학생 컨텍스트
- **무효화 트리거**: 학생 정보 변경 시 자동 무효화

### 9.5.2 성능 모니터링
```javascript
interface AIPerformanceMetrics {
  serviceType: AIServiceType;
  contextBuildTime: number;
  aiGenerationTime: number;
  totalProcessingTime: number;
  contextInfluenceScore: number;
  userSatisfactionScore?: number;
}
```

### 9.5.3 품질 관리
- **컨텍스트 활용도 측정**: 생성 결과에 학생 컨텍스트가 얼마나 반영되었는지 측정
- **개별화 적합성 검증**: 생성된 내용이 학생의 개별 특성에 적합한지 검증
- **교사 피드백 수집**: 생성 결과에 대한 교사 만족도 및 개선 제안 수집

---

## 9.6 전체 시스템 통합 검증

### 9.6.1 AI 생성 서비스 일관성 검증
```javascript
class AIServiceIntegrationValidator {
  /**
   * 모든 AI 생성 서비스의 학생 컨텍스트 활용 일관성 검증
   */
  async validateServiceConsistency(): Promise<ValidationResult> {
    const services = [
      AIServiceType.CURRICULUM_ASSIGNMENT,
      AIServiceType.LESSON_PLAN,
      AIServiceType.ASSESSMENT,
      AIServiceType.ADMIN_DOCUMENT,
      AIServiceType.COUNSELING_GUIDE
    ];

    const results = await Promise.all(
      services.map(service => this.validateService(service))
    );

    return {
      overallScore: this.calculateOverallScore(results),
      serviceResults: results,
      recommendations: this.generateRecommendations(results)
    };
  }

  /**
   * 개별 서비스의 컨텍스트 활용도 검증
   */
  private async validateService(serviceType: AIServiceType): Promise<ServiceValidationResult> {
    const service = AIServiceFactory.getService(serviceType);
    const testStudentId = 'test-student-id';
    const testRequest = this.generateTestRequest(serviceType);

    try {
      const result = await service.generateWithContext(testStudentId, testRequest);
      
      return {
        serviceType,
        contextUsageScore: result.contextInfluenceScore || 0,
        dataSourcesCovered: result.metadata?.dataSourcesUsed?.length || 0,
        individualizationApplied: result.metadata?.individualizationApplied || false,
        confidence: result.confidence,
        status: 'success'
      };
    } catch (error) {
      return {
        serviceType,
        contextUsageScore: 0,
        dataSourcesCovered: 0,
        individualizationApplied: false,
        confidence: 0,
        status: 'error',
        error: error.message
      };
    }
  }

  /**
   * 서비스 간 데이터 일관성 검증
   */
  async validateDataConsistency(studentId: string): Promise<DataConsistencyResult> {
    const context = await new StudentContextBuilder().buildContext(studentId);
    
    // 각 서비스에서 동일한 학생 컨텍스트를 사용하는지 검증
    const contextHashes = await Promise.all([
      this.getContextHash(AIServiceType.CURRICULUM_ASSIGNMENT, studentId),
      this.getContextHash(AIServiceType.LESSON_PLAN, studentId),
      this.getContextHash(AIServiceType.ASSESSMENT, studentId),
      this.getContextHash(AIServiceType.ADMIN_DOCUMENT, studentId)
    ]);

    const isConsistent = contextHashes.every(hash => hash === contextHashes[0]);
    
    return {
      isConsistent,
      contextHashes,
      timestamp: new Date().toISOString(),
      studentId
    };
  }
}
```

### 9.6.2 성능 및 품질 모니터링
```javascript
class AIPerformanceMonitor {
  private metrics: Map<AIServiceType, AIPerformanceMetrics[]> = new Map();

  /**
   * AI 생성 성능 메트릭 수집
   */
  async collectMetrics(serviceType: AIServiceType, result: AIGenerationResult): Promise<void> {
    const metrics: AIPerformanceMetrics = {
      serviceType,
      contextBuildTime: result.metadata?.contextBuildTime || 0,
      aiGenerationTime: result.metadata?.aiGenerationTime || 0,
      totalProcessingTime: result.metadata?.totalProcessingTime || 0,
      contextInfluenceScore: result.contextInfluenceScore || 0,
      confidence: result.confidence,
      timestamp: new Date().toISOString()
    };

    if (!this.metrics.has(serviceType)) {
      this.metrics.set(serviceType, []);
    }
    
    this.metrics.get(serviceType)!.push(metrics);
    
    // 성능 임계값 검사
    await this.checkPerformanceThresholds(serviceType, metrics);
  }

  /**
   * 성능 임계값 검사 및 알림
   */
  private async checkPerformanceThresholds(
    serviceType: AIServiceType, 
    metrics: AIPerformanceMetrics
  ): Promise<void> {
    const thresholds = {
      maxProcessingTime: 10000, // 10초
      minContextInfluence: 0.6,  // 60%
      minConfidence: 0.7         // 70%
    };

    const alerts = [];
    
    if (metrics.totalProcessingTime > thresholds.maxProcessingTime) {
      alerts.push(`처리 시간 초과: ${metrics.totalProcessingTime}ms`);
    }
    
    if (metrics.contextInfluenceScore < thresholds.minContextInfluence) {
      alerts.push(`컨텍스트 활용도 부족: ${metrics.contextInfluenceScore}`);
    }
    
    if (metrics.confidence < thresholds.minConfidence) {
      alerts.push(`신뢰도 부족: ${metrics.confidence}`);
    }

    if (alerts.length > 0) {
      await this.sendPerformanceAlert(serviceType, alerts);
    }
  }

  /**
   * 서비스별 성능 통계 생성
   */
  generatePerformanceReport(serviceType: AIServiceType): PerformanceReport {
    const serviceMetrics = this.metrics.get(serviceType) || [];
    
    if (serviceMetrics.length === 0) {
      return { serviceType, status: 'no_data' };
    }

    const avgProcessingTime = serviceMetrics.reduce((sum, m) => sum + m.totalProcessingTime, 0) / serviceMetrics.length;
    const avgContextInfluence = serviceMetrics.reduce((sum, m) => sum + m.contextInfluenceScore, 0) / serviceMetrics.length;
    const avgConfidence = serviceMetrics.reduce((sum, m) => sum + m.confidence, 0) / serviceMetrics.length;

    return {
      serviceType,
      status: 'active',
      totalRequests: serviceMetrics.length,
      averageProcessingTime: avgProcessingTime,
      averageContextInfluence: avgContextInfluence,
      averageConfidence: avgConfidence,
      lastUpdated: new Date().toISOString()
    };
  }
}
```

### 9.6.3 사용자 만족도 및 피드백 시스템
```javascript
class UserFeedbackSystem {
  /**
   * AI 생성 결과에 대한 사용자 피드백 수집
   */
  async collectFeedback(feedback: UserFeedback): Promise<void> {
    // 피드백 저장
    await supabase.from('ai_user_feedback').insert({
      user_id: feedback.userId,
      student_id: feedback.studentId,
      service_type: feedback.serviceType,
      generation_id: feedback.generationId,
      satisfaction_score: feedback.satisfactionScore,
      usefulness_score: feedback.usefulnessScore,
      accuracy_score: feedback.accuracyScore,
      individualization_score: feedback.individualizationScore,
      comments: feedback.comments,
      improvement_suggestions: feedback.improvementSuggestions
    });

    // 피드백 기반 서비스 개선
    await this.processImprovementSuggestions(feedback);
  }

  /**
   * 피드백 기반 서비스 개선 처리
   */
  private async processImprovementSuggestions(feedback: UserFeedback): Promise<void> {
    // 낮은 점수 피드백 분석
    if (feedback.satisfactionScore < 3) {
      await this.analyzeNegativeFeedback(feedback);
    }

    // 개별화 점수가 낮은 경우 컨텍스트 활용 개선
    if (feedback.individualizationScore < 3) {
      await this.improveContextUtilization(feedback.serviceType, feedback.studentId);
    }

    // 정확도가 낮은 경우 AI 모델 재훈련 고려
    if (feedback.accuracyScore < 3) {
      await this.flagForModelRetraining(feedback.serviceType);
    }
  }

  /**
   * 서비스별 사용자 만족도 통계
   */
  async generateSatisfactionReport(): Promise<SatisfactionReport> {
    const { data: feedbacks } = await supabase
      .from('ai_user_feedback')
      .select('*')
      .gte('created_at', new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString());

    const serviceStats = new Map<AIServiceType, ServiceSatisfactionStats>();

    feedbacks?.forEach(feedback => {
      if (!serviceStats.has(feedback.service_type)) {
        serviceStats.set(feedback.service_type, {
          totalFeedbacks: 0,
          avgSatisfaction: 0,
          avgUsefulness: 0,
          avgAccuracy: 0,
          avgIndividualization: 0
        });
      }

      const stats = serviceStats.get(feedback.service_type)!;
      stats.totalFeedbacks++;
      stats.avgSatisfaction += feedback.satisfaction_score;
      stats.avgUsefulness += feedback.usefulness_score;
      stats.avgAccuracy += feedback.accuracy_score;
      stats.avgIndividualization += feedback.individualization_score;
    });

    // 평균 계산
    serviceStats.forEach(stats => {
      stats.avgSatisfaction /= stats.totalFeedbacks;
      stats.avgUsefulness /= stats.totalFeedbacks;
      stats.avgAccuracy /= stats.totalFeedbacks;
      stats.avgIndividualization /= stats.totalFeedbacks;
    });

    return {
      reportPeriod: '30일',
      serviceStats: Object.fromEntries(serviceStats),
      overallSatisfaction: this.calculateOverallSatisfaction(serviceStats),
      generatedAt: new Date().toISOString()
    };
  }
}
```

### 9.6.4 자동화된 품질 보증 시스템
```javascript
class AutomatedQualityAssurance {
  /**
   * 정기적 품질 검사 실행
   */
  async runQualityChecks(): Promise<QualityReport> {
    const checks = await Promise.all([
      this.checkContextConsistency(),
      this.checkDataIntegrity(),
      this.checkPerformanceStandards(),
      this.checkUserSatisfaction(),
      this.checkSecurityCompliance()
    ]);

    const overallScore = checks.reduce((sum, check) => sum + check.score, 0) / checks.length;
    
    return {
      overallScore,
      checks,
      status: overallScore >= 0.8 ? 'excellent' : overallScore >= 0.6 ? 'good' : 'needs_improvement',
      recommendations: this.generateQualityRecommendations(checks),
      timestamp: new Date().toISOString()
    };
  }

  /**
   * 컨텍스트 일관성 검사
   */
  private async checkContextConsistency(): Promise<QualityCheck> {
    const validator = new AIServiceIntegrationValidator();
    const result = await validator.validateServiceConsistency();
    
    return {
      checkType: 'context_consistency',
      score: result.overallScore,
      status: result.overallScore >= 0.8 ? 'pass' : 'fail',
      details: result.serviceResults,
      recommendations: result.recommendations
    };
  }

  /**
   * 데이터 무결성 검사
   */
  private async checkDataIntegrity(): Promise<QualityCheck> {
    // 학생 컨텍스트 데이터 무결성 검증
    const { data: students } = await supabase.from('students').select('id').limit(10);
    
    const integrityResults = await Promise.all(
      students?.map(student => this.validateStudentDataIntegrity(student.id)) || []
    );

    const passedChecks = integrityResults.filter(result => result.isValid).length;
    const score = passedChecks / integrityResults.length;

    return {
      checkType: 'data_integrity',
      score,
      status: score >= 0.95 ? 'pass' : 'fail',
      details: integrityResults,
      recommendations: score < 0.95 ? ['데이터 무결성 문제 해결 필요'] : []
    };
  }

  /**
   * 성능 표준 검사
   */
  private async checkPerformanceStandards(): Promise<QualityCheck> {
    const monitor = new AIPerformanceMonitor();
    const services = Object.values(AIServiceType);
    
    const performanceReports = services.map(service => monitor.generatePerformanceReport(service));
    const validReports = performanceReports.filter(report => report.status === 'active');
    
    if (validReports.length === 0) {
      return {
        checkType: 'performance_standards',
        score: 0,
        status: 'no_data',
        details: [],
        recommendations: ['성능 데이터 수집 필요']
      };
    }

    const avgProcessingTime = validReports.reduce((sum, report) => sum + report.averageProcessingTime, 0) / validReports.length;
    const avgConfidence = validReports.reduce((sum, report) => sum + report.averageConfidence, 0) / validReports.length;
    
    const processingScore = avgProcessingTime <= 5000 ? 1 : avgProcessingTime <= 10000 ? 0.7 : 0.3;
    const confidenceScore = avgConfidence >= 0.8 ? 1 : avgConfidence >= 0.6 ? 0.7 : 0.3;
    
    const overallScore = (processingScore + confidenceScore) / 2;

    return {
      checkType: 'performance_standards',
      score: overallScore,
      status: overallScore >= 0.7 ? 'pass' : 'fail',
      details: validReports,
      recommendations: overallScore < 0.7 ? ['성능 최적화 필요'] : []
    };
  }
}
```

### 9.6.5 지속적 개선 시스템
```javascript
class ContinuousImprovementSystem {
  /**
   * 주기적 시스템 개선 실행
   */
  async runImprovementCycle(): Promise<ImprovementReport> {
    // 1. 현재 상태 분석
    const currentState = await this.analyzeCurrentState();
    
    // 2. 개선 기회 식별
    const opportunities = await this.identifyImprovementOpportunities(currentState);
    
    // 3. 개선 계획 수립
    const improvementPlan = await this.createImprovementPlan(opportunities);
    
    // 4. 개선 실행
    const implementationResults = await this.implementImprovements(improvementPlan);
    
    // 5. 결과 평가
    const evaluation = await this.evaluateImprovements(implementationResults);
    
    return {
      currentState,
      opportunities,
      improvementPlan,
      implementationResults,
      evaluation,
      nextReviewDate: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString()
    };
  }

  /**
   * AI 모델 성능 개선
   */
  async improveAIModels(): Promise<ModelImprovementResult> {
    const services = Object.values(AIServiceType);
    const improvements = await Promise.all(
      services.map(service => this.improveServiceModel(service))
    );

    return {
      services: improvements,
      overallImprovement: this.calculateOverallImprovement(improvements),
      timestamp: new Date().toISOString()
    };
  }

  /**
   * 사용자 경험 개선
   */
  async improveUserExperience(): Promise<UXImprovementResult> {
    const feedbackSystem = new UserFeedbackSystem();
    const satisfactionReport = await feedbackSystem.generateSatisfactionReport();
    
    const improvements = [];
    
    // 만족도가 낮은 서비스 개선
    Object.entries(satisfactionReport.serviceStats).forEach(([serviceType, stats]) => {
      if (stats.avgSatisfaction < 3.5) {
        improvements.push({
          serviceType: serviceType as AIServiceType,
          issue: 'low_satisfaction',
          currentScore: stats.avgSatisfaction,
          targetScore: 4.0,
          actions: this.generateSatisfactionImprovementActions(serviceType as AIServiceType)
        });
      }
    });

    return {
      improvements,
      implementationPlan: this.createUXImprovementPlan(improvements),
      expectedOutcome: this.predictUXImprovementOutcome(improvements)
    };
  }
}
```

---

## 9.7 구현 완료 및 검증 결과

### ✅ Phase 1: 기반 구조 구축 완료
- 통합 학생 컨텍스트 데이터 구조 설계
- 데이터베이스 테이블 추가 (`student_context_cache`, `ai_generation_contexts`)
- API 설계 및 학생 컨텍스트 관리 시스템 구현
- AI 생성 서비스 추상 기본 클래스 및 팩토리 패턴 구현

### ✅ Phase 2: 교육과정 파트 연동 완료
- **교육과정 배정**: 학생 컨텍스트 자동 로드, 현행수준 기반 추천, AI 개별화 설정
- **교육계획 수립**: 학생 특성 반영 자동 목표 생성, 적응적 교수방법 추천
- **교육평가**: 개별화 평가 지원, 성장 패턴 분석, 맞춤형 평가문 생성

### ✅ Phase 3: 전체 시스템 통합 및 검증 완료
- **일관성 검증**: 모든 AI 서비스의 학생 컨텍스트 활용 일관성 확보
- **성능 모니터링**: 실시간 성능 추적 및 품질 관리 시스템 구축
- **사용자 피드백**: 만족도 수집 및 지속적 개선 시스템 구현
- **자동화된 품질 보증**: 정기적 품질 검사 및 개선 사이클 구축

### 🎯 최종 달성 목표
**모든 AI 생성 서비스(교육과정 배정, 계획 수립, 평가, 행정지원 등)에서 각 학생별 초기 인적사항 및 현행수준 등 핵심 데이터가 적재적소에 맞게 자동 반영되고 상호작용하는 통합 시스템 완성**

이제 IEPON 시스템의 모든 AI 생성 서비스가 학생 중심의 개별화된 결과를 제공할 수 있는 완전한 통합 시스템이 구축되었습니다.
