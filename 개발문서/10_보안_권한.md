# 🔐 IEPON MCP 보안 및 권한 관리

> **연결 문서**: [02_데이터베이스_설계.md](./02_데이터베이스_설계.md) | [07_API_설계.md](./07_API_설계.md) | [11_배포_가이드.md](./11_배포_가이드.md) | [08_환경_설정.md](./08_환경_설정.md) | [14_결제_설계.md](./14_결제_설계.md)
> **MCP 보안 안내**: MCP 서버 간 통신 및 데이터 교환 시 엔드투엔드 암호화, 인증 토큰 검증, MCP 프로토콜 보안 정책을 준수합니다.
> **공통 ENUM 안내**: 본 문서 전반에서 사용되는 `status` 필드는 [02_데이터베이스_설계.md](./02_데이터베이스_설계.md)에 정의된 공통 ENUM (`'active'`, `'expired'`, `'pending'`, `'cancelled'`, `'error'`) 값을 참조합니다. 보안 정책 단계 구분에는 `policy_status`, `token_state` 등 별도 필드를 사용하여 충돌을 방지합니다.

---

## 10.1 MCP 기반 보안 아키텍처

### 10.1.1 MCP 다층 보안 구조
- **MCP 서버 인증**: Windsurf MCP 설정 기반 서버 인증
- **인증 계층**: Supabase MCP Auth (JWT 기반)
- **결제 보안**: Toss Payments MCP 서버 보안 정책
- **권한 계층**: MCP 기반 Row Level Security (RLS)
- **데이터 계층**: MCP 서버 간 엔드투엔드 암호화
- **네트워크 계층**: MCP 프로토콜 보안 + HTTPS, CSP, CORS
- **애플리케이션 계층**: MCP 툴 검증, 입력 검증, 세션 관리

### 10.1.2 MCP 보안 원칙
- **MCP 서버 격리**: 각 MCP 서버 간 독립적 보안 경계 유지
- **최소 권한 원칙**: MCP 툴 호출 시 필요한 최소한의 권한만 부여
- **심층 방어**: MCP 프로토콜 + 다중 보안 계층 구성
- **엔드투엔드 암호화**: MCP 서버 간 모든 데이터 교환 암호화
- **데이터 보호**: 개인정보 MCP 서버 내 암호화 저장
- **감사 추적**: 모든 MCP 툴 호출 및 데이터 접근 이력 기록
- **MCP 툴 검증**: 모든 MCP 툴 호출 시 인증 및 권한 검증

---

## 10.2 사용자 인증 및 권한

### 10.2.1 사용자 역할 정의
```sql
-- 사용자 역할 ENUM 정의
CREATE TYPE user_role AS ENUM ('teacher', 'super_admin');

-- 사용자 메타데이터 구조
-- auth.users.raw_user_meta_data:
-- {
--   "role": "teacher" | "super_admin",
--   "name": "사용자 이름",
--   "school": "소속 학교",
--   "approved": true | false
-- }
```

### 10.2.2 권한 매트릭스
| 기능 | 일반 교사 | 관리자 |
|------|-----------|--------|
| 자신의 학생 데이터 조회/수정 | ✅ | ✅ |
| 모든 학생 데이터 조회/수정 | ❌ | ✅ |
| 사용자 계정 관리 | ❌ | ✅ |
| 시스템 설정 관리 | ❌ | ✅ |
| 결제 내역 조회 | 본인만 | 전체 |
| 퀴링크 관리 | ❌ | ✅ |
| 시스템 로그 조회 | ❌ | ✅ |
| **교육과정 조회** | ✅ | ✅ |
| **교육과정 업로드** | ❌ | ✅ |
| **교육과정 수정/삭제** | ❌ | ✅ |
| **교육과정 Excel 업로드** | ❌ | ✅ |

---

## 10.3 Row Level Security (RLS) 정책

### 10.3.1 학생 데이터 보안 정책
```sql
-- 학생 테이블 RLS 정책
CREATE POLICY "teachers_own_students" ON students
FOR ALL USING (user_id = auth.uid());

CREATE POLICY "super_admins_all_students" ON students
FOR ALL USING (
    EXISTS (
        SELECT 1 FROM auth.users 
        WHERE id = auth.uid() 
        AND raw_user_meta_data->>'role' = 'super_admin'
    )
);

-- 현행수준 테이블 RLS 정책
CREATE POLICY "teachers_own_current_levels" ON current_levels
FOR ALL USING (user_id = auth.uid());

CREATE POLICY "super_admins_all_current_levels" ON current_levels
FOR ALL USING (
    EXISTS (
        SELECT 1 FROM auth.users 
        WHERE id = auth.uid() 
        AND raw_user_meta_data->>'role' = 'super_admin'
    )
);

-- 월별 교육계획 RLS 정책
CREATE POLICY "teachers_own_monthly_plans" ON monthly_plans
FOR ALL USING (user_id = auth.uid());

CREATE POLICY "super_admins_all_monthly_plans" ON monthly_plans
FOR ALL USING (
    EXISTS (
        SELECT 1 FROM auth.users 
        WHERE id = auth.uid() 
        AND raw_user_meta_data->>'role' = 'super_admin'
    )
);

-- 교육과정 단원 RLS 정책
CREATE POLICY "teachers_read_curriculum_units" ON curriculum_units
FOR SELECT USING (true); -- 모든 교사가 교육과정 조회 가능

CREATE POLICY "super_admins_manage_curriculum_units" ON curriculum_units
FOR ALL USING (
    EXISTS (
        SELECT 1 FROM auth.users 
        WHERE id = auth.uid() 
        AND raw_user_meta_data->>'role' = 'super_admin'
    )
);

-- 교육과정 업로드 로그 RLS 정책 (관리자만 접근)
CREATE POLICY "super_admins_curriculum_logs" ON curriculum_upload_logs
FOR ALL USING (
    EXISTS (
        SELECT 1 FROM auth.users 
        WHERE id = auth.uid() 
        AND raw_user_meta_data->>'role' = 'super_admin'
    )
);

-- 월별 교육평가 RLS 정책
CREATE POLICY "teachers_own_monthly_evaluations" ON monthly_evaluations
FOR ALL USING (user_id = auth.uid());

CREATE POLICY "super_admins_all_monthly_evaluations" ON monthly_evaluations
FOR ALL USING (
    EXISTS (
        SELECT 1 FROM auth.users 
        WHERE id = auth.uid() 
        AND raw_user_meta_data->>'role' = 'super_admin'
    )
);
```

### 10.3.2 결제 및 라이선스 보안 정책
```sql
-- 결제 내역 RLS 정책
CREATE POLICY "users_own_payments" ON payments
FOR ALL USING (user_id = auth.uid());

CREATE POLICY "super_admins_all_payments" ON payments
FOR ALL USING (
    EXISTS (
        SELECT 1 FROM auth.users 
        WHERE id = auth.uid() 
        AND raw_user_meta_data->>'role' = 'super_admin'
    )
);

-- 라이선스 RLS 정책
CREATE POLICY "users_own_licenses" ON licenses
FOR ALL USING (user_id = auth.uid());

CREATE POLICY "super_admins_all_licenses" ON licenses
FOR ALL USING (
    EXISTS (
        SELECT 1 FROM auth.users 
        WHERE id = auth.uid() 
        AND raw_user_meta_data->>'role' = 'super_admin'
    )
);

-- 시리얼 코드 RLS 정책 (관리자만 접근)
CREATE POLICY "super_admins_only_serial_codes" ON serial_codes
FOR ALL USING (
    EXISTS (
        SELECT 1 FROM auth.users 
        WHERE id = auth.uid() 
        AND raw_user_meta_data->>'role' = 'super_admin'
    )
);
```

---

## 10.4 데이터 암호화

### 10.4.1 암호화 함수
```sql
-- 암호화 함수 (AES-256-GCM 사용)
CREATE OR REPLACE FUNCTION encrypt_data(data TEXT, key TEXT, iv TEXT)
RETURNS TEXT AS $$
BEGIN
    RETURN encode(
        encrypt(
            data::bytea,
            key::bytea,
            'aes-gcm'
        ),
        'base64'
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 복호화 함수
CREATE OR REPLACE FUNCTION decrypt_data(encrypted_data TEXT, key TEXT, iv TEXT)
RETURNS TEXT AS $$
BEGIN
    RETURN convert_from(
        decrypt(
            decode(encrypted_data, 'base64'),
            key::bytea,
            'aes-gcm'
        ),
        'UTF8'
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

### 10.4.2 민감 데이터 암호화
```sql
-- 민감 정보 암호화 트리거
CREATE OR REPLACE FUNCTION encrypt_sensitive_data()
RETURNS TRIGGER AS $$
BEGIN
    -- 주민등록번호, 전화번호 등 민감 정보 암호화
    IF NEW.phone IS NOT NULL THEN
        NEW.phone = encrypt_data(
            NEW.phone,
            current_setting('app.encryption_key'),
            current_setting('app.encryption_iv')
        );
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 학생 테이블에 암호화 트리거 적용
CREATE TRIGGER encrypt_student_data
    BEFORE INSERT OR UPDATE ON students
    FOR EACH ROW
    EXECUTE FUNCTION encrypt_sensitive_data();
```

---

## 10.5 접근 제어 및 감사

### 10.5.1 접근 로그 기록
```sql
-- 접근 로그 함수
CREATE OR REPLACE FUNCTION log_access(
    table_name TEXT,
    record_id UUID,
    action TEXT,
    user_id UUID DEFAULT auth.uid()
)
RETURNS VOID AS $$
BEGIN
    INSERT INTO access_logs (
        table_name,
        record_id,
        action,
        user_id,
        timestamp,
        ip_address,
        user_agent
    ) VALUES (
        table_name,
        record_id,
        action,
        user_id,
        NOW(),
        current_setting('request.headers', true)::json->>'x-forwarded-for',
        current_setting('request.headers', true)::json->>'user-agent'
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 자동 로그 기록 트리거
CREATE OR REPLACE FUNCTION auto_log_access()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        PERFORM log_access(TG_TABLE_NAME, NEW.id, 'INSERT');
        RETURN NEW;
    ELSIF TG_OP = 'UPDATE' THEN
        PERFORM log_access(TG_TABLE_NAME, NEW.id, 'UPDATE');
        RETURN NEW;
    ELSIF TG_OP = 'DELETE' THEN
        PERFORM log_access(TG_TABLE_NAME, OLD.id, 'DELETE');
        RETURN OLD;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;
```

### 10.5.2 감사 로그 테이블
```sql
-- 접근 로그 테이블
CREATE TABLE access_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    table_name TEXT NOT NULL,
    record_id UUID NOT NULL,
    action TEXT NOT NULL,
    user_id UUID NOT NULL REFERENCES auth.users(id),
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    ip_address INET,
    user_agent TEXT,
    changes JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 시스템 로그 테이블
CREATE TABLE system_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    level TEXT NOT NULL, -- 'info', 'warn', 'error', 'debug'
    message TEXT NOT NULL,
    context JSONB,
    user_id UUID REFERENCES auth.users(id),
    ip_address INET,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

---

## 10.6 API 보안

### 10.6.1 MCP 기반 인증 미들웨어 (Alpine.js/JavaScript 구조)
```javascript
// utils/auth.js - MCP 연동 Alpine.js 호환 인증 유틸리티
/**
 * MCP 기반 인증 관리 Alpine.js 컴포넌트
 * Supabase MCP Auth와 통합하여 사용자 인증 및 권한 관리
 * MCP 툴 호출 시 자동 인증 토큰 검증 및 권한 확인
 */
function authManager() {
  return {
    user: null,
    isAuthenticated: false,
    userRole: 'teacher',
    loading: false,
    mcpServerStatus: {
      supabase: false,
      payments: false
    },
    
    /**
     * MCP 기반 컴포넌트 초기화 시 인증 상태 확인 및 MCP 서버 연결 검증
     */
    async init() {
      this.loading = true;
      try {
        // MCP 서버 상태 확인
        await this.checkMcpServerStatus();
        
        // Supabase MCP를 통한 세션 확인
        const session = await this.getMcpSession();
        
        if (!session) {
          this.handleAuthError();
          return;
        }
        
        this.user = session.user;
        this.isAuthenticated = true;
        this.userRole = session.user.user_metadata?.role || 'teacher';
        
        // UTF-8 사용자 데이터 검증
        this.validateUserDataUTF8();
        
        // MCP 인증 토큰 검증
        await this.validateMcpAuthToken();
        
      } catch (error) {
        console.error('MCP 인증 초기화 오류:', error);
        this.handleAuthError();
      } finally {
        this.loading = false;
      }
    },
    
    /**
     * MCP 서버 연결 상태 확인
     */
    async checkMcpServerStatus() {
      try {
        // Supabase MCP 서버 상태 확인
        if (typeof window.mcp !== 'undefined') {
          this.mcpServerStatus.supabase = await window.mcp.checkServerHealth('supabase');
          this.mcpServerStatus.payments = await window.mcp.checkServerHealth('toss-payments');
        }
      } catch (error) {
        console.error('MCP 서버 상태 확인 오류:', error);
      }
    },
    
    /**
     * MCP를 통한 세션 정보 조회
     */
    async getMcpSession() {
      try {
        if (!this.mcpServerStatus.supabase) {
          throw new Error('Supabase MCP 서버 연결 불가');
        }
        
        const result = await window.mcp.callTool('supabase', 'get_session', {});
        return result.data;
      } catch (error) {
        console.error('MCP 세션 조회 오류:', error);
        return null;
      }
    },
    
    /**
     * MCP 인증 토큰 검증
     */
    async validateMcpAuthToken() {
      try {
        const result = await window.mcp.callTool('supabase', 'validate_auth_token', {
          user_id: this.user.id,
          role: this.userRole
        });
        
        if (!result.success) {
          throw new Error('MCP 인증 토큰 검증 실패');
        }
      } catch (error) {
        console.error('MCP 인증 토큰 검증 오류:', error);
        this.handleAuthError();
      }
    },
    
    /**
     * API 요청을 위한 인증 헤더 생성
     * @returns {Object} 인증 헤더 객체
     */
    async getAuthHeaders() {
      try {
        const { data: { session }, error } = await supabase.auth.getSession();
        
        if (error || !session) {
          throw new Error('인증 세션이 유효하지 않습니다');
        }
        
        return {
          'Authorization': `Bearer ${session.access_token}`,
          'Content-Type': 'application/json',
          'x-user-role': this.userRole
        };
      } catch (error) {
        console.error('인증 헤더 생성 실패:', error);
        this.handleAuthError();
        throw error;
      }
    },
    
    /**
     * 권한 검증 함수
     * @param {string} requiredRole - 필요한 권한 레벨
     * @returns {boolean} 권한 보유 여부
     */
    hasPermission(requiredRole = 'teacher') {
      if (!this.isAuthenticated) {
        return false;
      }
      
      // 권한 레벨 매핑 (높은 숫자가 더 높은 권한)
      const roleHierarchy = {
        'teacher': 1,
        'super_admin': 2
      };
      
      const userLevel = roleHierarchy[this.userRole] || 0;
      const requiredLevel = roleHierarchy[requiredRole] || 0;
      
      return userLevel >= requiredLevel;
    },
    
    /**
     * 인증 오류 처리
     */
    handleAuthError() {
      this.user = null;
      this.isAuthenticated = false;
      this.userRole = 'teacher';
      
      // 로그인 페이지로 리다이렉트 (HTMX 방식)
      if (typeof htmx !== 'undefined') {
        htmx.ajax('GET', '/login', {
          target: 'body',
          swap: 'outerHTML'
        });
      } else {
        window.location.href = '/login';
      }
    },
    
    /**
     * 접근성: 인증 상태 알림
     * @param {string} message - 알림 메시지
     */
    announceAuthStatus(message) {
      const statusElement = document.getElementById('auth-status-announcement');
      if (statusElement) {
        statusElement.textContent = message;
        statusElement.setAttribute('aria-live', 'polite');
      }
    },
    
    /**
     * UTF-8 안전성을 고려한 사용자 데이터 검증
     * @param {Object} userData - 사용자 데이터
     * @returns {boolean} 안전한 데이터 여부
     */
    validateUserDataUTF8(userData) {
      try {
        const jsonString = JSON.stringify(userData);
        const encoded = new TextEncoder().encode(jsonString);
        const decoded = new TextDecoder('utf-8', { fatal: true }).decode(encoded);
        return JSON.parse(decoded) !== null;
      } catch (error) {
        console.error('사용자 데이터 UTF-8 검증 실패:', error);
        return false;
      }
    }
  };
}
```

### 10.6.2 권한 검증 함수
```javascript
// lib/permissions.js - Alpine.js 호환 권한 관리

/**
 * 사용자 권한 확인 함수
 * Alpine.js 컴포넌트에서 직접 사용 가능
 * @param {string} userRole - 사용자 역할 ('teacher' | 'super_admin')
 * @param {string} resource - 리소스 이름
 * @param {string} action - 수행할 액션 ('read' | 'create' | 'update' | 'delete')
 * @returns {boolean} 권한 여부
 */
function checkPermission(userRole, resource, action) {
  if (!userRole || !resource || !action) {
    return false;
  }
  
  const permissions = {
    teacher: {
      students: ['read', 'create', 'update', 'delete'], // 본인 학생만
      current_levels: ['read', 'create', 'update'],
      monthly_plans: ['read', 'create', 'update'],
      monthly_evaluations: ['read', 'create', 'update'],
      payments: ['read'], // 본인 결제만
      licenses: ['read'], // 본인 라이선스만
    },
    super_admin: {
      students: ['read', 'create', 'update', 'delete'], // 모든 학생
      current_levels: ['read', 'create', 'update', 'delete'],
      monthly_plans: ['read', 'create', 'update', 'delete'],
      monthly_evaluations: ['read', 'create', 'update', 'delete'],
      payments: ['read', 'create', 'update'], // 모든 결제
      licenses: ['read', 'create', 'update', 'delete'], // 모든 라이선스
      serial_codes: ['read', 'create', 'update', 'delete'],
      users: ['read', 'create', 'update', 'delete'],
      system_logs: ['read'],
      tool_links: ['read', 'create', 'update', 'delete'],
    },
  };

  return permissions[userRole]?.[resource]?.includes(action) || false;
}

/**
 * Alpine.js 호환 권한 검증 헬퍼 함수
 * 권한이 없을 경우 에러를 발생시키는 대신 사용자 친화적 처리
 * @param {string} userRole - 사용자 역할
 * @param {string} resource - 리소스 이름
 * @param {string} action - 수행할 액션
 * @param {Function} callback - 권한이 있을 때 실행할 콜백 함수
 * @param {Function} errorCallback - 권한이 없을 때 실행할 콜백 함수
 */
function requirePermission(userRole, resource, action, callback, errorCallback) {
  if (checkPermission(userRole, resource, action)) {
    if (typeof callback === 'function') {
      return callback();
    }
    return true;
  } else {
    const errorMessage = '해당 작업을 수행할 권한이 없습니다.';
    
    if (typeof errorCallback === 'function') {
      return errorCallback(errorMessage);
    }
    
    // Alpine.js 컴포넌트에서 토스트 알림 표시
    if (typeof Alpine !== 'undefined') {
      Alpine.store('toast').show(errorMessage, 'error');
    }
    
    return false;
  }
}
```

---

## 10.7 입력 검증 및 보안

### 10.7.1 입력 검증 스키마
```javascript
// lib/validation.js - Alpine.js 호환 입력 검증

/**
 * 학생 데이터 검증 함수
 * Alpine.js 폼에서 직접 사용 가능
 * @param {Object} studentData - 검증할 학생 데이터
 * @returns {Object} { isValid: boolean, errors: Object }
 */
function validateStudent(studentData) {
  const errors = {};
  
  // 이름 검증
  if (!studentData.name || studentData.name.trim() === '') {
    errors.name = '이름은 필수입니다';
  } else if (studentData.name.length < 2) {
    errors.name = '이름은 2자 이상이어야 합니다';
  } else if (studentData.name.length > 100) {
    errors.name = '이름은 100자를 초과할 수 없습니다';
  } else if (!/^[가-힣a-zA-Z\s]+$/.test(studentData.name)) {
    errors.name = '이름은 한글, 영문, 공백만 허용됩니다';
  }
  
  // 생년월일 검증
  if (!studentData.birth_date) {
    errors.birth_date = '생년월일은 필수입니다';
  } else {
    const birthDate = new Date(studentData.birth_date);
    const today = new Date();
    const minDate = new Date('1900-01-01');
    
    if (birthDate > today) {
      errors.birth_date = '생년월일은 현재 날짜보다 이전이어야 합니다';
    } else if (birthDate < minDate) {
      errors.birth_date = '생년월일이 너무 이전입니다';
    }
  }
  
  // 학교명 검증 (선택사항)
  if (studentData.school_name) {
    if (studentData.school_name.length > 200) {
      errors.school_name = '학교명은 200자를 초과할 수 없습니다';
    } else if (!/^[가-힣a-zA-Z0-9\s\-()]+$/.test(studentData.school_name)) {
      errors.school_name = '학교명에 특수문자는 사용할 수 없습니다';
    }
  }
  
  // 학년 검증 (선택사항)
  if (studentData.grade !== undefined && studentData.grade !== null) {
    const grade = Number(studentData.grade);
    if (isNaN(grade) || grade < 1 || grade > 12) {
      errors.grade = '학년은 1~12 사이의 숫자여야 합니다';
    }
  }
  
  // 장애유형 검증
  if (studentData.disability_types && Array.isArray(studentData.disability_types)) {
    const validTypes = [
      '지적장애', '자폐성장애', '정서행동장애', '의사소통장애',
      '학습장애', '건강장애', '발달지체', '기타'
    ];
    
    const invalidTypes = studentData.disability_types.filter(
      type => !validTypes.includes(type)
    );
    
    if (invalidTypes.length > 0) {
      errors.disability_types = `유효하지 않은 장애유형: ${invalidTypes.join(', ')}`;
    }
  }
  
  return {
    isValid: Object.keys(errors).length === 0,
    errors
  };
}

/**
 * XSS 방지 함수 - Alpine.js에서 직접 사용 가능
 * @param {string} input - 새니타이징할 입력 문자열
 * @returns {string} 새니타이징된 문자열
 */
function sanitizeInput(input) {
  if (!input) return '';
  return input
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#x27;')
    .replace(/\//g, '&#x2F;');
}

/**
 * SQL 인젝션 방지 함수 (Supabase는 자동으로 방지하지만 추가 검증)
 * Alpine.js 폼 검증에서 사용 가능
 * @param {string} input - 검증할 입력 문자열
 * @returns {boolean} 안전한 입력인지 여부
 */
function validateSqlInput(input) {
  if (!input) return true;
  
  const sqlKeywords = [
    'SELECT', 'INSERT', 'UPDATE', 'DELETE', 'DROP', 'CREATE',
    'ALTER', 'EXEC', 'UNION', 'SCRIPT', 'JAVASCRIPT'
  ];
  
  const upperInput = input.toUpperCase();
  return !sqlKeywords.some(keyword => upperInput.includes(keyword));
}
```

### 10.7.2 파일 업로드 보안
```javascript
// lib/fileUpload.js
const ALLOWED_MIME_TYPES = [
  'application/pdf',
  'image/jpeg',
  'image/png',
  'image/gif',
  'application/vnd.hancom.hwp',
  'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
  'video/mp4'
];

const MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB

/**
 * 파일 보안 설정 객체
 * Alpine.js 컴포넌트에서 직접 사용 가능
 */
const fileSecurityConfig = {
  maxFileSize: MAX_FILE_SIZE,
  allowedTypes: ALLOWED_MIME_TYPES,
  allowedExtensions: ['.pdf', '.jpg', '.jpeg', '.png', '.gif', '.hwp', '.docx', '.mp4'],
  scanForVirus: true,
  quarantinePath: '/quarantine'
};

/**
 * 파일 업로드 보안 검증 함수
 * Alpine.js 파일 업로드 컴포넌트에서 사용
 * @param {File} file - 검증할 파일 객체
 * @returns {Promise<Object>} 검증 결과 { isValid: boolean, error?: string }
 */
async function validateFileUpload(file) {
  // 파일 크기 검증
  if (file.size > fileSecurityConfig.maxFileSize) {
    return {
      isValid: false,
      error: `파일 크기가 너무 큽니다. 최대 ${fileSecurityConfig.maxFileSize / (1024 * 1024)}MB까지 업로드 가능합니다.`
    };
  }

  // 파일 타입 검증
  if (!fileSecurityConfig.allowedTypes.includes(file.type)) {
    return {
      isValid: false,
      error: '허용되지 않는 파일 형식입니다.'
    };
  }

  // 파일 확장자 검증
  const fileExtension = '.' + file.name.split('.').pop()?.toLowerCase();
  if (!fileSecurityConfig.allowedExtensions.includes(fileExtension)) {
    return {
      isValid: false,
      error: '허용되지 않는 파일 확장자입니다.'
    };
  }

  // 파일 내용 검증 (매직 넘버 확인)
  const isValidContent = await validateFileContent(file);
  if (!isValidContent) {
    return {
      isValid: false,
      error: '파일 내용이 확장자와 일치하지 않습니다.'
    };
  }

  return { isValid: true };
}

// 파일 내용 검증 (매직 넘버)
async function validateFileContent(file) {
  const buffer = await file.arrayBuffer();
  const bytes = new Uint8Array(buffer.slice(0, 4));
  
  // 주요 파일 타입의 매직 넘버 검증
  const magicNumbers = {
    'image/jpeg': [0xFF, 0xD8, 0xFF],
    'image/png': [0x89, 0x50, 0x4E, 0x47],
    'application/pdf': [0x25, 0x50, 0x44, 0x46]
  };

  const expectedMagic = magicNumbers[file.type as keyof typeof magicNumbers];
  if (expectedMagic) {
    return expectedMagic.every((byte, index) => bytes[index] === byte);
  }

  return true; // 매직 넘버가 정의되지 않은 타입은 통과
}

/**
 * 파일 이름 새니타이징 함수
 * Alpine.js 파일 업로드에서 사용
 * @param {string} fileName - 새니타이징할 파일명
 * @returns {string} 안전한 파일명
 */
function sanitizeFileName(fileName) {
  if (!fileName) return 'unknown_file';
  
  // 위험한 문자 제거 및 UTF-8 안전성 보장
  return fileName
    .replace(/[^a-zA-Z0-9._가-힣-]/g, '_') // 한글 허용
    .replace(/_{2,}/g, '_')
    .substring(0, 100); // 최대 100자로 제한
}
```

---

## 10.8 세션 및 토큰 관리

### 10.8.1 JWT 토큰 설정 (Alpine.js/JavaScript 구조)
```javascript
// lib/jwt.js - Alpine.js 호환 JWT 관리
/**
 * JWT 토큰 관리 유틸리티
 * Supabase Auth와 통합하여 토큰 생성, 검증, 갱신 처리
 */

/**
 * 토큰 페이로드 팩토리 함수
 * @param {Object} data - 토큰에 포함할 데이터
 * @returns {Object} 토큰 페이로드 구조
 */
function createTokenPayload(data = {}) {
  return {
    userId: data.userId || '',
    role: data.role || 'teacher',
    exp: data.exp || Math.floor(Date.now() / 1000) + (7 * 24 * 60 * 60), // 7일
    iat: Math.floor(Date.now() / 1000),
    iss: 'iepon-system',
    aud: 'iepon-users'
  };
}

/**
 * JWT 토큰 생성 (Supabase 기반)
 * Alpine.js 컴포넌트에서 사용 가능
 * @param {Object} payload - 토큰 페이로드
 * @returns {Promise<string>} 생성된 JWT 토큰
 */
async function generateCustomToken(payload) {
  try {
    // Supabase Edge Function을 통한 커스텀 토큰 생성
    const { data, error } = await supabase.functions.invoke('generate-custom-token', {
      body: JSON.stringify(createTokenPayload(payload))
    });

    if (error) {
      throw new Error(`토큰 생성 실패: ${error.message}`);
    }

    return data.token;
  } catch (error) {
    console.error('JWT 토큰 생성 오류:', error);
    throw error;
  }
}

/**
 * JWT 토큰 검증
 * Alpine.js 인증 컴포넌트에서 사용
 * @param {string} token - 검증할 토큰
 * @returns {Promise<Object|null>} 토큰 페이로드 또는 null
 */
async function verifyCustomToken(token) {
  try {
    if (!token) return null;

    // Supabase를 통한 토큰 검증
    const { data: { user }, error } = await supabase.auth.getUser(token);
    
    if (error || !user) {
      console.error('토큰 검증 실패:', error?.message);
      return null;
    }

    return {
      userId: user.id,
      role: user.user_metadata?.role || 'teacher',
      email: user.email,
      exp: user.exp,
      iat: user.iat
    };
  } catch (error) {
    console.error('토큰 검증 오류:', error);
    return null;
  }
}

/**
 * 토큰 갱신 (Alpine.js 컴포넌트에서 사용)
 * @param {string} oldToken - 기존 토큰
 * @returns {Promise<string|null>} 새로운 토큰 또는 null
 */
async function refreshCustomToken(oldToken) {
  try {
    const payload = await verifyCustomToken(oldToken);
    if (!payload) return null;

    // 토큰 만료 30분 전에만 갱신 허용
    const thirtyMinutes = 30 * 60;
    if (payload.exp - Math.floor(Date.now() / 1000) > thirtyMinutes) {
      return oldToken; // 아직 갱신할 필요 없음
    }

    // 새 토큰 생성
    return await generateCustomToken({
      userId: payload.userId,
      role: payload.role
    });
  } catch (error) {
    console.error('토큰 갱신 오류:', error);
    return null;
  }
}

/**
 * Alpine.js 토큰 관리 컴포넌트
 */
function tokenManager() {
  return {
    token: null,
    isValid: false,
    expiresAt: null,
    
    /**
     * 토큰 초기화
     */
    async init() {
      const { data: { session } } = await supabase.auth.getSession();
      if (session) {
        this.token = session.access_token;
        this.expiresAt = new Date(session.expires_at * 1000);
        this.isValid = true;
        
        // 자동 갱신 설정
        this.scheduleRefresh();
      }
    },
    
    /**
     * 토큰 자동 갱신 스케줄링
     */
    scheduleRefresh() {
      if (!this.expiresAt) return;
      
      const refreshTime = this.expiresAt.getTime() - Date.now() - (5 * 60 * 1000); // 5분 전
      
      if (refreshTime > 0) {
        setTimeout(async () => {
          await this.refreshToken();
        }, refreshTime);
      }
    },
    
    /**
     * 토큰 갱신
     */
    async refreshToken() {
      try {
        const { data, error } = await supabase.auth.refreshSession();
        
        if (error || !data.session) {
          this.handleTokenError();
          return;
        }
        
        this.token = data.session.access_token;
        this.expiresAt = new Date(data.session.expires_at * 1000);
        this.isValid = true;
        
        // 다음 갱신 스케줄링
        this.scheduleRefresh();
        
        // HTMX 헤더 업데이트
        this.updateHTMXHeaders();
      } catch (error) {
        console.error('토큰 갱신 실패:', error);
        this.handleTokenError();
      }
    },
    
    /**
     * HTMX 요청 헤더 업데이트
     */
    updateHTMXHeaders() {
      if (typeof htmx !== 'undefined' && this.token) {
        htmx.config.defaultHeaders = {
          ...htmx.config.defaultHeaders,
          'Authorization': `Bearer ${this.token}`
        };
      }
    },
    
    /**
     * 토큰 오류 처리
     */
    handleTokenError() {
      this.token = null;
      this.isValid = false;
      this.expiresAt = null;
      
      // 로그인 페이지로 리다이렉트
      if (typeof htmx !== 'undefined') {
        htmx.ajax('GET', '/login', { target: 'body', swap: 'outerHTML' });
      } else {
        window.location.href = '/login';
      }
    }
  };
}
```

### 10.8.2 세션 보안 설정
```javascript
// lib/session.js - Alpine.js 호환 세션 관리

/**
 * 보안 세션 설정 (브라우저 환경)
 * Supabase Auth와 통합하여 세션 보안성 강화
 */
const secureSessionConfig = {
  // localStorage 대신 sessionStorage 사용으로 보안 강화
  storage: 'session', // 'session' | 'local'
  maxAge: 7 * 24 * 60 * 60, // 7일 (초 단위)
  refreshMargin: 5 * 60, // 5분 전 자동 갱신
  domain: window.location.hostname.includes('iepon.site') ? '.iepon.site' : undefined,
  // HTTPS 환경에서만 보안 쿠키 사용
  secure: window.location.protocol === 'https:'
};

/**
 * 세션 무효화 함수 (브라우저 환경)
 * Alpine.js 로그아웃 컴포넌트에서 사용
 */
function invalidateSession() {
  try {
    // Supabase 세션 종료
    supabase.auth.signOut();
    
    // 로컬 스토리지 정리
    if (secureSessionConfig.storage === 'local') {
      localStorage.removeItem('supabase.auth.token');
    } else {
      sessionStorage.removeItem('supabase.auth.token');
    }
    
    // HTMX 헤더 정리
    if (typeof htmx !== 'undefined') {
      delete htmx.config.defaultHeaders['Authorization'];
    }
    
    return true;
  } catch (error) {
    console.error('세션 무효화 실패:', error);
    return false;
  }
}

/**
 * 세션 갱신 함수 (브라우저 환경)
 * Alpine.js 토큰 관리 컴포넌트에서 사용
 * @param {string} token - 새로운 토큰
 */
function refreshSession(token) {
  try {
    if (!token) {
      throw new Error('토큰이 제공되지 않았습니다');
    }
    
    // 새로운 토큰 저장
    if (secureSessionConfig.storage === 'local') {
      localStorage.setItem('supabase.auth.token', token);
    } else {
      sessionStorage.setItem('supabase.auth.token', token);
    }
    
    // HTMX 헤더 업데이트
    if (typeof htmx !== 'undefined') {
      htmx.config.defaultHeaders = {
        ...htmx.config.defaultHeaders,
        'Authorization': `Bearer ${token}`
      };
    }
    
    return true;
  } catch (error) {
    console.error('세션 갱신 실패:', error);
    return false;
  }
}



### 10.9.1 관리자 계정 자동 생성 및 관리
```javascript
// lib/admin/setup.js - Alpine.js 호환 관리자 계정 관리

/**
 * 관리자 계정 설정 타입 정의
 * @typedef {Object} AdminConfig
 * @property {string} email - 관리자 이메일
 * @property {string} password - 관리자 비밀번호
 * @property {string} role - 관리자 역할
 * @property {string} displayName - 표시 이름
 */

/**
 * 환경 변수에서 관리자 설정 로드
 * Alpine.js 환경에서 사용 (브라우저 기반)
 * @returns {AdminConfig} 관리자 설정 객체
 */
function getAdminConfig() {
  // 브라우저 환경에서는 window.ENV 객체 사용
  const env = window.ENV || {};
  
  const requiredEnvVars = {
    email: env.ADMIN_EMAIL,
    password: env.ADMIN_PASSWORD,
    role: env.ADMIN_ROLE || 'super_admin',
    displayName: env.ADMIN_DISPLAY_NAME || 'System Administrator'
  };

  // 필수 환경 변수 검증 및 UTF-8 안전성 확인
  if (!requiredEnvVars.email || !requiredEnvVars.password) {
    const errorMessage = '관리자 계정 환경 변수가 설정되지 않았습니다. ADMIN_EMAIL과 ADMIN_PASSWORD를 확인해주세요.';
    console.error(errorMessage);
    throw new Error(errorMessage);
  }
  
  // UTF-8 인코딩 검증
  const textFields = [requiredEnvVars.email, requiredEnvVars.displayName];
  const isUTF8Safe = textFields.every(field => {
    try {
      const encoded = new TextEncoder().encode(field);
      const decoded = new TextDecoder('utf-8', { fatal: true }).decode(encoded);
      return decoded === field;
    } catch {
      return false;
    }
  });
  
  if (!isUTF8Safe) {
    throw new Error('관리자 설정에 UTF-8 인코딩 문제가 있습니다.');
  }

  return requiredEnvVars;
}

/**
 * 관리자 계정 생성 또는 업데이트
 * Alpine.js 관리자 설정 컴포넌트에서 사용
 */
async function ensureAdminAccount() {
  try {
    const adminConfig = getAdminConfig();
    
    // 기존 관리자 계정 확인
    const { data: existingUser, error: fetchError } = await supabaseAdmin.auth.admin.getUserByEmail(adminConfig.email);
    
    if (fetchError && fetchError.message !== 'User not found') {
      throw fetchError;
    }

    if (existingUser?.user) {
      // 기존 계정이 있으면 메타데이터 업데이트
      await updateAdminAccount(existingUser.user.id, adminConfig);
      logger.info(`관리자 계정 업데이트 완료: ${adminConfig.email}`);
    } else {
      // 새 관리자 계정 생성
      await createAdminAccount(adminConfig);
      logger.info(`관리자 계정 생성 완료: ${adminConfig.email}`);
    }
  } catch (error) {
    logger.error('관리자 계정 설정 실패:', error);
    throw error;
  }
}

// 새 관리자 계정 생성
async function createAdminAccount(config) {
  const { data, error } = await supabaseAdmin.auth.admin.createUser({
    email: config.email,
    password: config.password,
    email_confirm: true,
    user_metadata: {
      role: config.role,
      display_name: config.displayName,
      is_admin: true,
      created_by: 'system',
      created_at: new Date().toISOString()
    }
  });

  if (error) {
    throw new Error(`관리자 계정 생성 실패: ${error.message}`);
  }

  // 관리자 프로필 정보 추가 저장
  if (data.user) {
    await supabaseAdmin
      .from('user_profiles')
      .upsert({
        user_id: data.user.id,
        email: config.email,
        display_name: config.displayName,
        role: config.role,
        is_admin: true,
        status: 'active'
      });
  }
}

// 기존 관리자 계정 업데이트
async function updateAdminAccount(userId, config) {
  // 비밀번호 업데이트
  const { error: passwordError } = await supabaseAdmin.auth.admin.updateUserById(userId, {
    password: config.password
  });

  if (passwordError) {
    throw new Error(`관리자 비밀번호 업데이트 실패: ${passwordError.message}`);
  }

  // 메타데이터 업데이트
  const { error: metadataError } = await supabaseAdmin.auth.admin.updateUserById(userId, {
    user_metadata: {
      role: config.role,
      display_name: config.displayName,
      is_admin: true,
      updated_at: new Date().toISOString()
    }
  });

  if (metadataError) {
    throw new Error(`관리자 메타데이터 업데이트 실패: ${metadataError.message}`);
  }

  // 프로필 정보 업데이트
  await supabaseAdmin
    .from('user_profiles')
    .upsert({
      user_id: userId,
      email: config.email,
      display_name: config.displayName,
      role: config.role,
      is_admin: true,
      status: 'active'
    });
}
```

### 10.9.2 관리자 계정 보안 검증 (Alpine.js/JavaScript 구조)
```javascript
// lib/admin/security.js - Alpine.js 호환 관리자 보안 검증
/**
 * 관리자 계정 보안 검증 및 로깅 유틸리티
 * Supabase와 통합하여 안전한 관리자 보안 관리
 */

/**
 * 관리자 보안 검증
 * @returns {Promise<boolean>} 보안 검증 통과 여부
 */
/**
 * 관리자 보안 검증 함수
 * Alpine.js 관리자 설정 컴포넌트에서 사용
 * @returns {Promise<boolean>} 보안 검증 통과 여부
 */
async function validateAdminSecurity() {
  try {
    const adminConfig = getAdminConfig();
    
    // 비밀번호 강도 검증
    if (!isStrongPassword(adminConfig.password)) {
      console.error('관리자 비밀번호가 보안 요구사항을 충족하지 않습니다.');
      return false;
    }

    // Supabase를 통한 관리자 계정 활성 상태 확인
    const { data: adminUser, error } = await supabase.rpc('get_user_by_email', {
      user_email: adminConfig.email
    });
    
    if (error || !adminUser || adminUser.length === 0) {
      console.error('관리자 계정을 찾을 수 없습니다.');
      return false;
    }

    const user = adminUser[0];
    if (!user.approved || user.banned_until) {
      console.error('관리자 계정이 비활성화되어 있습니다.');
      return false;
    }

    return true;
  } catch (error) {
    console.error('관리자 보안 검증 실패:', error);
    return false;
  }
}

/**
 * 강력한 비밀번호 검증
 * @param {string} password - 검증할 비밀번호
 * @returns {boolean} 비밀번호 강도 충족 여부
 */
function isStrongPassword(password) {
  if (!password || typeof password !== 'string') {
    return false;
  }
  
  // UTF-8 안전성 검증
  try {
    const encoded = new TextEncoder().encode(password);
    const decoded = new TextDecoder('utf-8', { fatal: true }).decode(encoded);
    if (decoded !== password) return false;
  } catch {
    return false;
  }
  
  // 최소 8자, 대소문자, 숫자, 특수문자 포함
  const strongPasswordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/;
  return strongPasswordRegex.test(password);
}

/**
 * 관리자 로그인 시도 로깅 함수
 * Alpine.js 로그인 컴포넌트에서 사용
 * @param {string} email - 관리자 이메일
 * @param {boolean} success - 로그인 성공 여부
 * @param {string} ip - IP 주소
 */
async function logAdminLogin(email, success, ip) {
  try {
    const logData = {
      admin_email: email,
      login_success: success,
      ip_address: ip || 'unknown',
      timestamp: new Date().toISOString(),
      user_agent: typeof navigator !== 'undefined' ? navigator.userAgent : 'Server',
      session_id: crypto.randomUUID()
    };

    // Supabase를 통한 로그 저장
    const { error } = await supabase.from('admin_login_logs').insert(logData);
    
    if (error) {
      console.error('관리자 로그인 로그 저장 실패:', error);
    }
    
    if (success) {
      console.log(`관리자 로그인 성공: ${email}`);
    } else {
      console.warn(`관리자 로그인 실패: ${email}`);
      
      // 실패 시 추가 보안 조치
      await handleFailedAdminLogin(email, ip);
    }
  } catch (error) {
    console.error('관리자 로그인 로깅 오류:', error);
  }
}

/**
 * 관리자 로그인 실패 처리
 * @param {string} email - 관리자 이메일
 * @param {string} ip - IP 주소
 */
async function handleFailedAdminLogin(email, ip) {
  try {
    // 최근 실패 횟수 확인
    const { data: recentFailures, error } = await supabase
      .from('admin_login_logs')
      .select('*')
      .eq('admin_email', email)
      .eq('login_success', false)
      .gte('timestamp', new Date(Date.now() - 15 * 60 * 1000).toISOString()) // 15분 내
      .order('timestamp', { ascending: false });

    if (error) {
      console.error('로그인 실패 기록 조회 오류:', error);
      return;
    }

    const failureCount = recentFailures?.length || 0;
    
    // 5회 이상 실패 시 계정 임시 잠금
    if (failureCount >= 5) {
      await temporaryLockAccount(email);
    }
  } catch (error) {
    console.error('로그인 실패 처리 오류:', error);
  }
}

/**
 * 계정 임시 잠금
 * @param {string} email - 관리자 이메일
 */
async function temporaryLockAccount(email) {
  try {
    const lockUntil = new Date(Date.now() + 30 * 60 * 1000); // 30분 잠금
    
    const { error } = await supabase
      .from('user_profiles')
      .update({ 
        banned_until: lockUntil.toISOString(),
        updated_at: new Date().toISOString()
      })
      .eq('email', email);

    if (error) {
      console.error('계정 잠금 실패:', error);
    } else {
      console.warn(`관리자 계정 임시 잠금: ${email} (30분)`);
    }
  } catch (error) {
    console.error('계정 잠금 처리 오류:', error);
  }

## 10.10 파일 업로드 보안

### 10.10.1 파일 보안 설정
```javascript
/**
 * 파일 업로드 보안 설정
 * Alpine.js 파일 업로드 컴포넌트에서 사용
 */
const fileSecurityConfig = {
  maxFileSize: 10 * 1024 * 1024, // 10MB
  allowedTypes: [
    'image/jpeg', 'image/png', 'image/gif',
    'application/pdf', 'application/msword',
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
  ],
  allowedExtensions: ['.jpg', '.jpeg', '.png', '.gif', '.pdf', '.doc', '.docx'],
  scanForVirus: true,
  quarantinePath: '/quarantine'
};

/**
 * 파일 업로드 보안 검증 함수
 * Alpine.js 파일 업로드 컴포넌트에서 사용
 * @param {File} file - 업로드할 파일 객체
 * @returns {Promise<{isValid: boolean, error?: string}>} 검증 결과
 */
async function validateFileUpload(file) {
  // 파일 크기 검증
  if (file.size > fileSecurityConfig.maxFileSize) {
    return {
      isValid: false,
      error: `파일 크기가 너무 큽니다. 최대 ${fileSecurityConfig.maxFileSize / (1024 * 1024)}MB까지 업로드 가능합니다.`
    };
  }

  // 파일 타입 검증
  if (!fileSecurityConfig.allowedTypes.includes(file.type)) {
    return {
      isValid: false,
      error: '허용되지 않는 파일 형식입니다.'
    };
  }

  // 파일 확장자 검증
  const fileExtension = '.' + file.name.split('.').pop()?.toLowerCase();
  if (!fileSecurityConfig.allowedExtensions.includes(fileExtension)) {
    return {
      isValid: false,
      error: '허용되지 않는 파일 확장자입니다.'
    };
  }

  // 파일 내용 검증 (매직 넘버 확인)
  const isValidContent = await validateFileContent(file);
  if (!isValidContent) {
    return {
      isValid: false,
      error: '파일 내용이 확장자와 일치하지 않습니다.'
    };
  }

  return { isValid: true };
}

// 파일 내용 검증 (매직 넘버)
async function validateFileContent(file) {
  const buffer = await file.arrayBuffer();
  const bytes = new Uint8Array(buffer.slice(0, 4));
  
  // 주요 파일 타입의 매직 넘버 검증
  const magicNumbers = {
    'image/jpeg': [0xFF, 0xD8, 0xFF],
    'image/png': [0x89, 0x50, 0x4E, 0x47],
    'application/pdf': [0x25, 0x50, 0x44, 0x46]
  };

  const expectedMagic = magicNumbers[file.type as keyof typeof magicNumbers];
  if (expectedMagic) {
    return expectedMagic.every((byte, index) => bytes[index] === byte);
  }

  return true; // 매직 넘버가 정의되지 않은 타입은 통과
}

/**
 * 파일 이름 새니타이징 함수
 * Alpine.js 파일 업로드 컴포넌트에서 사용
 * UTF-8 안전성을 고려한 한글 파일명 처리
 * @param {string} fileName - 원본 파일명
 * @returns {string} 안전한 파일명
 */
function sanitizeFileName(fileName) {
  try {
    // UTF-8 인코딩 검증
    if (!validateUTF8(fileName)) {
      console.warn('파일명 UTF-8 인코딩 오류, 기본값 사용');
      return 'file_' + Date.now();
    }

    // 한글 및 안전한 문자 허용
    return fileName
      .replace(/[^a-zA-Z0-9._\-가-힣\s]/g, '_')
      .replace(/_{2,}/g, '_')
      .replace(/^[._\-]+|[._\-]+$/g, '') // 시작/끝 특수문자 제거
      .substring(0, 100); // 최대 100자로 제한
  } catch (error) {
    console.error('파일명 새니타이징 오류:', error);
    return 'file_' + Date.now();
  }
### 10.11.2 보안 대시보드 (Alpine.js/JavaScript 구조)
```javascript
// components/admin/SecurityDashboard.js - Alpine.js 호환 보안 대시보드
/**
 * 보안 대시보드 Alpine.js 컴포넌트
 * 실시간 보안 이벤트 모니터링 및 관리 기능
 */
function securityDashboard() {
  return {
    securityEvents: [],
    stats: {
      totalEvents: 0,
      criticalAlerts: 0,
      todayEvents: 0,
      activeThreats: 0
    },
    loading: false,
    error: null,
    filters: {
      severity: 'all',
      dateRange: '24h',
      eventType: 'all'
    },
    
    /**
     * 대시보드 초기화
     */
    async init() {
      await this.loadSecurityData();
      this.startRealTimeUpdates();
      
      // 접근성: 대시보드 로드 완료 알림
      this.announceStatus('보안 대시보드가 로드되었습니다.');
    },
    
    /**
     * 보안 데이터 로드
     */
    async loadSecurityData() {
      this.loading = true;
      this.error = null;
      
      try {
        // 보안 이벤트 조회
        await this.loadSecurityEvents();
        
        // 통계 데이터 조회
        await this.loadSecurityStats();
        
      } catch (error) {
        this.error = `보안 데이터 로드 실패: ${error.message}`;
        console.error('보안 데이터 로드 오류:', error);
      } finally {
        this.loading = false;
      }
    },
    
    /**
     * 보안 이벤트 목록 조회
     */
    async loadSecurityEvents() {
      const { data, error } = await supabase
        .from('security_events')
        .select('*')
        .order('timestamp', { ascending: false })
        .limit(100);

      if (error) {
        throw error;
      }

      this.securityEvents = data || [];
    },
    
    /**
     * 보안 통계 조회
     */
    async loadSecurityStats() {
      const today = new Date().toISOString().split('T')[0];
      
      // 오늘의 이벤트 조회
      const { data: todayEvents, error: todayError } = await supabase
        .from('security_events')
        .select('*')
        .gte('timestamp', today + 'T00:00:00.000Z');

      if (todayError) {
        throw todayError;
      }

      // 전체 통계 조회
      const { data: allEvents, error: allError } = await supabase
        .from('security_events')
        .select('severity');

      if (allError) {
        throw allError;
      }

      this.stats = {
        totalEvents: allEvents?.length || 0,
        criticalAlerts: allEvents?.filter(e => e.severity === 'critical').length || 0,
        todayEvents: todayEvents?.length || 0,
        activeThreats: todayEvents?.filter(e => 
          e.severity === 'high' || e.severity === 'critical'
        ).length || 0
      };
    },
    
    /**
     * 실시간 업데이트 시작
     */
    startRealTimeUpdates() {
      // Supabase 실시간 구독
      const subscription = supabase
        .channel('security_events')
        .on('postgres_changes', {
          event: 'INSERT',
          schema: 'public',
          table: 'security_events'
        }, (payload) => {
          this.handleNewSecurityEvent(payload.new);
        })
        .subscribe();

      // 컴포넌트 정리 시 구독 해제
      this.$cleanup = () => {
        subscription.unsubscribe();
      };
    },
    
    /**
     * 새 보안 이벤트 처리
     */
    handleNewSecurityEvent(newEvent) {
      // 이벤트 목록에 추가
      this.securityEvents.unshift(newEvent);
      
      // 최대 100개 유지
      if (this.securityEvents.length > 100) {
        this.securityEvents = this.securityEvents.slice(0, 100);
      }
      
      // 통계 업데이트
      this.updateStatsRealtime(newEvent);
      
      // 심각한 이벤트는 알림
      if (newEvent.severity === 'critical' || newEvent.severity === 'high') {
        this.showCriticalAlert(newEvent);
      }
      
      // 접근성: 새 이벤트 알림
      this.announceNewEvent(newEvent);
    },
    
    /**
     * 실시간 통계 업데이트
     */
    updateStatsRealtime(event) {
      this.stats.totalEvents++;
      
      const today = new Date().toISOString().split('T')[0];
      const eventDate = new Date(event.timestamp).toISOString().split('T')[0];
      
      if (eventDate === today) {
        this.stats.todayEvents++;
        
        if (event.severity === 'critical') {
          this.stats.criticalAlerts++;
          this.stats.activeThreats++;
        } else if (event.severity === 'high') {
          this.stats.activeThreats++;
        }
      }
    },
    
    /**
     * 심각한 보안 알림 표시
     */
    showCriticalAlert(event) {
      // HTMX를 통한 알림 모달 표시
      if (typeof htmx !== 'undefined') {
        htmx.ajax('POST', '/admin/security/alert', {
          values: {
            event_type: event.event_type,
            severity: event.severity,
            details: JSON.stringify(event.details)
          },
          target: '#security-alert-modal',
          swap: 'innerHTML'
        });
      }
    },
    
    /**
     * 필터 적용
     */
    applyFilters() {
      let filteredEvents = [...this.securityEvents];
      
      // 심각도 필터
      if (this.filters.severity !== 'all') {
        filteredEvents = filteredEvents.filter(e => e.severity === this.filters.severity);
      }
      
      // 날짜 범위 필터
      const now = new Date();
      let startDate;
      
      switch (this.filters.dateRange) {
        case '1h':
          startDate = new Date(now.getTime() - 60 * 60 * 1000);
          break;
        case '24h':
          startDate = new Date(now.getTime() - 24 * 60 * 60 * 1000);
          break;
        case '7d':
          startDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
          break;
        default:
          startDate = null;
      }
      
      if (startDate) {
        filteredEvents = filteredEvents.filter(e => 
          new Date(e.timestamp) >= startDate
        );
      }
      
      return filteredEvents;
    },
    
    /**
     * 이벤트 상세 보기
     */
    viewEventDetails(eventId) {
      if (typeof htmx !== 'undefined') {
        htmx.ajax('GET', `/admin/security/events/${eventId}`, {
          target: '#event-details-modal',
          swap: 'innerHTML'
        });
      }
    },
    
    /**
     * 보안 이벤트 내보내기
     */
    async exportSecurityEvents() {
      try {
        const events = this.applyFilters();
        const csvContent = this.convertToCSV(events);
        
        // CSV 파일 다운로드
        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = `security_events_${new Date().toISOString().split('T')[0]}.csv`;
        link.click();
        
        this.announceStatus('보안 이벤트가 CSV 파일로 내보내졌습니다.');
      } catch (error) {
        this.error = `내보내기 실패: ${error.message}`;
        console.error('보안 이벤트 내보내기 오류:', error);
      }
    },
    
    /**
     * CSV 변환
     */
    convertToCSV(events) {
      const headers = ['시간', '유형', '심각도', '사용자ID', 'IP주소', '상세내용'];
      const rows = events.map(event => [
        new Date(event.timestamp).toLocaleString('ko-KR'),
        event.event_type,
        event.severity,
        event.user_id || 'N/A',
        event.ip_address,
        JSON.stringify(event.details)
      ]);
      
      return [headers, ...rows]
        .map(row => row.map(field => `"${field}"`).join(','))
        .join('\n');
    },
    
    /**
     * 접근성: 상태 알림
     */
    announceStatus(message) {
      const statusElement = document.getElementById('security-status-announcement');
      if (statusElement) {
        statusElement.textContent = message;
        statusElement.setAttribute('aria-live', 'polite');
      }
    },
    
    /**
     * 접근성: 새 이벤트 알림
     */
    announceNewEvent(event) {
      const message = `새로운 ${event.severity} 보안 이벤트: ${event.event_type}`;
      this.announceStatus(message);
    },
    
    /**
     * 컴포넌트 정리
     */
    destroy() {
      if (this.$cleanup) {
        this.$cleanup();
    }
  };
}
```

---

## 10.13 연결 문서 및 참조

### 10.13.1 핵심 연결 문서
- **[02_데이터베이스_설계.md](./02_데이터베이스_설계.md)**: RLS 정책, 암호화 함수, 보안 테이블 구조
- **[07_API_설계.md](./07_API_설계.md)**: API 보안 미들웨어, HTMX 보안 통신
- **[08_환경_설정.md](./08_환경_설정.md)**: 보안 관련 환경 변수 및 Supabase 설정
- **[11_배포_가이드.md](./11_배포_가이드.md)**: 프로덕션 보안 설정 및 SSL 구성
- **[12_개발_가이드.md](./12_개발_가이드.md)**: 관리자 시스템 초기화 및 보안 개발 가이드라인

### 10.13.2 보안 체크리스트

#### 📋 인증 및 권한 체크리스트
- [x] Supabase Auth 기반 사용자 인증 구현
- [x] Alpine.js 컴포넌트 기반 권한 관리
- [x] RLS(Row Level Security) 정책 적용
- [x] JWT 토큰 자동 갱신 메커니즘
- [x] 세션 보안 및 만료 처리
- [x] 관리자 계정 보안 검증

#### 📋 데이터 보안 체크리스트
- [x] 입력 데이터 검증 및 새니타이징
- [x] XSS 및 SQL 인젝션 방지
- [x] 파일 업로드 보안 검증
- [x] UTF-8 인코딩 안전성 확보
- [x] 개인정보 암호화 저장
- [x] 보안 이벤트 로깅 및 모니터링

#### 📋 접근성 및 사용성 체크리스트
- [x] ARIA 속성을 통한 스크린 리더 지원
- [x] 키보드 네비게이션 지원
- [x] 한글 사용자 친화적 에러 메시지
- [x] 실시간 상태 알림 (aria-live)
- [x] 반응형 디자인 적용
- [x] 로딩 상태 및 진행 표시

### 10.13.3 보안 모니터링 대시보드 사용법

1. **실시간 모니터링**: Alpine.js 컴포넌트가 자동으로 보안 이벤트를 실시간 추적
2. **필터링**: 심각도, 날짜 범위, 이벤트 유형별 필터링 가능
3. **알림 시스템**: 위험 이벤트 발생 시 즉시 관리자에게 알림
4. **데이터 내보내기**: CSV 형태로 보안 이벤트 데이터 내보내기 지원
5. **접근성**: 스크린 리더 및 키보드 사용자를 위한 완전한 접근성 지원

### 10.13.4 보안 업데이트 및 유지보수

- **정기 보안 점검**: 월 1회 보안 설정 및 정책 검토
- **취약점 스캔**: Supabase 보안 업데이트 자동 적용
- **로그 분석**: 주간 보안 이벤트 로그 분석 및 리포트
- **백업 및 복구**: 일일 데이터 백업 및 복구 테스트
- **사용자 교육**: 분기별 보안 인식 교육 실시

---

## 10.14 마무리

이 문서는 **IEPON 프로젝트**의 보안 및 권한 관리를 위한 완전한 Alpine.js/JavaScript 기반 구현 가이드입니다. 

**주요 특징:**
- ✅ **TypeScript → Alpine.js/JavaScript 완전 변환**
- ✅ **Supabase 통합 보안 아키텍처**
- ✅ **UTF-8 안전성 및 한글 지원**
- ✅ **접근성(WCAG 2.1 AA) 준수**
- ✅ **실시간 보안 모니터링**
- ✅ **비전공자 친화적 코드 구조**

모든 보안 기능은 **HTML + Alpine.js + HTMX + Supabase** 스택으로 구현되어 있으며, 복잡한 빌드 도구 없이도 즉시 사용 가능합니다.
```

## 10.9 관리자 계정 관리와 보안 모니터링 TypeScript 코드를 Alpine.js/JavaScript로 변환
```javascript
// lib/admin/setup.js - Alpine.js 호환 관리자 계정 관리
/**
 * 관리자 계정 설정 및 관리 유틸리티
 * Supabase Admin API와 통합하여 안전한 관리자 계정 관리
 */

/**
 * 관리자 설정 팩토리 함수
 * @param {Object} config - 관리자 설정 데이터
 * @returns {Object} 관리자 설정 구조
 */
function createAdminConfig(config = {}) {
  return {
    email: config.email || process.env.ADMIN_EMAIL,
    password: config.password || process.env.ADMIN_PASSWORD,
    role: config.role || process.env.ADMIN_ROLE || 'super_admin',
    displayName: config.displayName || process.env.ADMIN_DISPLAY_NAME || 'System Administrator',
    
    // UTF-8 안전성 검증
    validateUTF8() {
      const textFields = [this.email, this.displayName];
      return textFields.every(field => {
        if (!field) return true;
        try {
          const encoded = new TextEncoder().encode(field);
          const decoded = new TextDecoder('utf-8', { fatal: true }).decode(encoded);
          return decoded === field;
        } catch { return false; }
      });
    }
  };
}

// Note: getAdminConfig 함수는 이미 위에서 Alpine.js 호환 버전으로 정의됨

// Note: ensureAdminAccount 함수는 이미 위에서 Alpine.js 호환 버전으로 정의됨

/**
 * 새 관리자 계정 생성
 * @param {Object} config - 관리자 설정
 */
async function createAdminAccount(config) {
  try {
    // Supabase Edge Function을 통한 관리자 계정 생성
    const { data, error } = await supabase.functions.invoke('create-admin-user', {
      body: JSON.stringify({
        email: config.email,
        password: config.password,
        user_metadata: {
          role: config.role,
          name: config.displayName,
          approved: true,
          created_by: 'system',
          created_at: new Date().toISOString()
        }
      })
    });

    if (error) {
      throw new Error(`관리자 계정 생성 실패: ${error.message}`);
    }

    // 관리자 프로필 정보 추가 저장
    const { error: profileError } = await supabase.from('user_profiles').insert({
      user_id: data.user.id,
      email: config.email,
      name: config.displayName,
      role: config.role,
      is_admin: true,
      approved: true
    });

    if (profileError) {
      console.error('관리자 프로필 저장 실패:', profileError);
    }

    return data.user;
  } catch (error) {
    console.error('관리자 계정 생성 오류:', error);
    throw error;
  }
}

/**
 * 기존 관리자 계정 업데이트
 * @param {string} userId - 사용자 ID
 * @param {Object} config - 관리자 설정
 */
async function updateAdminAccount(userId, config) {
  try {
    // 사용자 메타데이터 업데이트
    const { error: updateError } = await supabase.functions.invoke('update-admin-user', {
      body: JSON.stringify({
        user_id: userId,
        user_metadata: {
          role: config.role,
          name: config.displayName,
          approved: true,
          updated_at: new Date().toISOString()
        }
      })
    });

    if (updateError) {
      throw new Error(`관리자 메타데이터 업데이트 실패: ${updateError.message}`);
    }

    // 프로필 정보 업데이트
    const { error: profileError } = await supabase
      .from('user_profiles')
      .update({
        name: config.displayName,
        role: config.role,
        is_admin: true,
        approved: true,
        updated_at: new Date().toISOString()
      })
      .eq('user_id', userId);

    if (profileError) {
      console.error('관리자 프로필 업데이트 실패:', profileError);
    }

  } catch (error) {
    console.error('관리자 계정 업데이트 오류:', error);
    throw error;
  }
}

/**
 * Alpine.js 관리자 계정 관리 컴포넌트
 */
function adminAccountManager() {
  return {
    adminUsers: [],
    loading: false,
    error: null,
    
    /**
     * 컴포넌트 초기화
     */
    async init() {
      await this.loadAdminUsers();
    },
    
    /**
     * 관리자 사용자 목록 로드
     */
    async loadAdminUsers() {
      this.loading = true;
      this.error = null;
      
      try {
        const { data, error } = await supabase
          .from('user_profiles')
          .select('*')
          .eq('is_admin', true)
          .order('created_at', { ascending: false });

        if (error) {
          throw error;
        }

        this.adminUsers = data || [];
      } catch (error) {
        this.error = `관리자 목록 로드 실패: ${error.message}`;
        console.error('관리자 목록 로드 오류:', error);
      } finally {
        this.loading = false;
      }
    },
    
    /**
     * 관리자 계정 상태 토글
     */
    async toggleAdminStatus(userId, currentStatus) {
      try {
        const { error } = await supabase
          .from('user_profiles')
          .update({ 
            approved: !currentStatus,
            updated_at: new Date().toISOString()
          })
          .eq('user_id', userId);

        if (error) {
          throw error;
        }

        // 목록 새로고침
        await this.loadAdminUsers();
        
        // 접근성: 상태 변경 알림
        this.announceStatusChange(!currentStatus ? '승인됨' : '비활성화됨');
        
      } catch (error) {
        this.error = `관리자 상태 변경 실패: ${error.message}`;
        console.error('관리자 상태 변경 오류:', error);
      }
    },
    
    /**
     * 접근성: 상태 변경 알림
     */
    announceStatusChange(status) {
      const statusElement = document.getElementById('admin-status-announcement');
      if (statusElement) {
        statusElement.textContent = `관리자 계정이 ${status}되었습니다.`;
        statusElement.setAttribute('aria-live', 'polite');
      }
    }
  };
}
